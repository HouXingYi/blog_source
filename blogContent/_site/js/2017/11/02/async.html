<!DOCTYPE html>
<html>
  <head>
      
  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

<!-- CSS -->

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://houxingyi.github.io//js/2017/11/02/async.html">
  <link rel="alternate" type="application/rss+xml" title="侯星伊的个人博客" href="https://houxingyi.github.io//feed.xml">

<!-- Google font -->

  <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Noto Sans">

<!-- font awesome -->

<link rel="stylesheet" href="/css/font-awesome/css/font-awesome.min.css">

</head>


  

  

  </head>

  <body>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>js异步编程解决方案</title>
  <meta name="description" content="在JavaScript中，函数作为一等公民，使用上非常自由，无论调用，或者作为参数，或者作为返回值均可。">
</head>


  <div class="wrapper">
          <header class="post-header">

    <center><div class="post-title" itemprop="name headline">js异步编程解决方案</div>

		<div class="post-meta"><i class="fa fa-calendar-o"></i> <time datetime="02 Nov 2017" itemprop="datePublished">Nov 2 2017</time>

		&nbsp;&nbsp;•&nbsp;&nbsp;<i class="fa fa-user-secret"></i> <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span itemprop="name">HouXingYi</span>
        
		<br>
		<!--<i class="fa fa-eye"></i> <span id="busuanzi_value_page_pv"><i class="fa fa-spinner fa-pulse"></i></span>˚C</span>-->
	</div>

        
        <div class="post-tags">
        
		<a class="post-tags-item" href="https://houxingyi.github.io//tags/">异步编程</a>
        
	</div>
    </center>
    
</header>

<article class="post" itemscope itemtype="http://schema.org/BlogPosting">
<div class="post-content">
    <center>
	
	<p></p>
	
    </center>
	<h2>Directory</h2>
</div>

<div id="category"></div>

<div class="post-content" itemprop="articleBody">
    <p>在JavaScript中，函数作为一等公民，使用上非常自由，无论调用，或者作为参数，或者作为返回值均可。</p>

<p>于是在无论是前端的事件驱动回调函数中，还是在nodejs中的异步IO，我们可以看见大量的回调函数。所谓的回调函数，就是把函数作为参数传入，并在将来的某个时候”回头调用”。</p>

<p>回调函数通常作为异步编程的一个解决方案，但是回调函数有许多问题</p>

<h2 id="回调函数的问题">回调函数的问题</h2>

<h3 id="问题一回调地狱">问题一：回调地狱</h3>

<div class="highlighter-rouge"><pre class="highlight"><code>var fs = require('fs');
fs.readFile('./text1.txt', 'utf8', function(err, data){
    console.log("text1 file content: " + data);
    fs.readFile('./text2.txt', 'utf8', function(err, data){
        console.log("text2 file content: " + data);
    });
});
</code></pre>
</div>
<p>上面是我们在进行nodejs编程的时候经常会遇见的场景。前端进行异步请求的时候也经常会遇见这样的场景。当回调嵌套过深的时候，就会出现以下场景。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>doSomethingAsync1(function(){
    doSomethingAsync2(function(){
        doSomethingAsync3(function(){
            doSomethingAsync4(function(){
               doSomethingAsync5(function(){
                    // code...
                });
            });
        });
    });
});
</code></pre>
</div>
<p>所以这种嵌套过深的情况有时候是不可忍受的，我们称之为“回调地狱”或“回调金字塔”</p>

<h3 id="问题二异步编程的理解">问题二：异步编程的理解</h3>

<p>我们的大脑习惯顺序思考问题，当要做一件事情的时候，我们会思考先做A再做B然后做C…。然而用回调函数写的异步代码则违反了我们天生的思考原则。</p>

<p>你能够很快的说出以下代码的执行顺序吗。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>doA(function(){
    doC();

    doD(function(){
        doF();
    })

    doE();
})

doB();
</code></pre>
</div>

<p>对于这样的代码，我们需要很大的努力才可以理解。也就是说，可读性很差。</p>

<h2 id="回调函数的代替解决方案">回调函数的代替解决方案</h2>

<h3 id="拆解function">拆解function</h3>

<p>我们可以通过将各部分的任务拆解为单个函数</p>
<div class="highlighter-rouge"><pre class="highlight"><code>function getData(count) {
    get(`/sampleget?count=${count}`, data =&gt; {
        console.log(data);
    });
}

function queryDB(kw) {
    db.find(`select * from sample where kw = ${kw}`, (err, res) =&gt; {
        getData(res.length);
    });
}

function readFile(filepath) {
    fs.readFile(filepath, 'utf-8', (err, content) =&gt; {
        let keyword = content.substring(0, 5);
        queryDB(keyword);
    });
}
</code></pre>
</div>

<h3 id="事件发布订阅模式">事件发布/订阅模式</h3>

<p>采用发布订阅模式进行解耦</p>

<div class="highlighter-rouge"><pre class="highlight"><code>const events = require('events');
const eventEmitter = new events.EventEmitter();

eventEmitter.on('db', (err, kw) =&gt; {
    db.find(`select * from sample where kw = ${kw}`, (err, res) =&gt; {
        eventEmitter('get', res.length);
    });
});

eventEmitter.on('get', (err, count) =&gt; {
    get(`/sampleget?count=${count}`, data =&gt; {
        console.log(data);
    });
});

fs.readFile('./sample.txt', 'utf-8', (err, content) =&gt; {
    let keyword = content.substring(0, 5);
    eventEmitter. emit('db', keyword);
});
</code></pre>
</div>
<p>以上两种解决方案确实可以解决一定问题，但终究没有摆脱回调函数的模式。</p>

<h3 id="promise">Promise</h3>

<p>ES 6中原生提供了Promise对象，Promise对象代表了某个未来才会知道结果的事件(一般是一个异步操作)，并且这个事件对外提供了统一的API，可供进一步处理。</p>

<p>使用Promise对象可以用同步操作的流程写法来表达异步操作，避免了层层嵌套的异步回调，代码也更加清晰易懂，方便维护。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>var fs = require('fs')
var read = function (filename){
    var promise = new Promise(function(resolve, reject){
        fs.readFile(filename, 'utf8', function(err, data){
            if (err){
                reject(err);
            }
            resolve(data);
        })
    });
    return promise;
}
read('./text1.txt')
.then(function(data){
    console.log(data);
return read('./text2.txt');
})
.then(function(data){
    console.log(data);
});
</code></pre>
</div>
<h3 id="generator">Generator</h3>

<p>Generator 函数有多种理解角度。语法上，首先可以把它理解成，Generator 函数是一个状态机，封装了多个内部状态。</p>

<p>执行 Generator 函数会返回一个遍历器对象，也就是说，Generator 函数除了状态机，还是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历 Generator 函数内部的每一个状态。</p>

<p>形式上，Generator 函数是一个普通函数，但是有两个特征。一是，function关键字与函数名之间有一个星号；二是，函数体内部使用yield表达式，定义不同的内部状态（yield在英语里的意思就是“产出”）。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>function* helloWorldGenerator() {
  yield 'hello';
  yield 'world';
  yield 'end';
  return 'ending';
}
hw.next()
// { value: 'hello', done: false }

hw.next()
// { value: 'world', done: false }

hw.next()
// { value: 'end', done: true }

hw.next()
// { value: undefined, done: true }
</code></pre>
</div>
<p>上面代码定义了一个 Generator 函数helloWorldGenerator，它内部有三个yield表达式（hello和world、end），即该函数有三个状态：hello，world，end 和 return 语句（结束执行）。</p>

<p>然后，Generator 函数的调用方法与普通函数一样，也是在函数名后面加上一对圆括号。不同的是，调用 Generator 函数后，该<code class="highlighter-rouge">函数并不执行</code>，返回的也不是函数运行结果，而是一个指向内部状态的指针对象，也就是遍历器对象（Iterator Object）。</p>

<p>下一步，必须调用遍历器对象的next方法，使得指针移向下一个状态。也就是说，每次调用next方法，内部指针就从函数头部或上一次停下来的地方开始执行，直到遇到下一个yield表达式（或return语句）为止。换言之，Generator 函数是分段执行的，yield表达式是暂停执行的标记，而next方法可以恢复执行。</p>

<h2 id="asyncawait">async/await</h2>

<p>async/await是ES7中的异步解决方案，可以看我的这篇博文。</p>

<p><a href="https://houxingyi.github.io/js/2017/07/15/AsyncAwaitTran.html">[译]在10分钟内解释JavaScript Async/Await</a></p>

<h2 id="结尾">结尾</h2>

<p>结合以上，我们可以有五种方法来解决回调地狱的问题</p>

<ul>
  <li>拆解function</li>
  <li>事件发布/订阅模式</li>
  <li>Promise</li>
  <li>Generator</li>
  <li>async/await</li>
</ul>


</div>

<div>
	
	<div class="eof"></div>
	
</div>

<!--先不分享-->
<!-- <div class="share">
    <p>Share this post with: </p>
	<a href="https://twitter.com/intent/tweet?text=js异步编程解决方案@&amp;url=https://houxingyi.github.io//js/2017/11/02/async.html" class="twitter-share">
		<span class="fa-stack fa-lg">
			<i class="fa fa-circle fa-stack-2x"></i>
			<i class="fa fa-twitter fa-stack-1x fa-inverse"></i>
		</span>
	</a>
    
	<a href="https://www.facebook.com/sharer/sharer.php?u=https://houxingyi.github.io//js/2017/11/02/async.html" class="facebook-share">
		<span class="fa-stack fa-lg">
			<i class="fa fa-circle fa-stack-2x"></i>
			<i class="fa fa-facebook fa-stack-1x fa-inverse"></i>
		</span>
	</a>
    
	<a href="https://plus.google.com/share?url=https://houxingyi.github.io//js/2017/11/02/async.html" class="googleplus-share">
		<span class="fa-stack fa-lg">
			<i class="fa fa-circle fa-stack-2x"></i>
			<i class="fa fa-google-plus fa-stack-1x fa-inverse"></i>
		</span>
	</a>
</div>
 -->

<!-- <div id="disqus_thread"></div>


 
</div>
  -->


<div id="container"></div>
<link rel="stylesheet" href="/gitment/default.css">
<script src="/gitment/gitment.browser.js"></script>
<script>
var gitment = new Gitment({
  id:window.location.pathname,
  owner: 'HouXingYi',
  repo: 'HouXingYi.github.io',
  oauth: {
    client_id: 'd8225497d80663e0c270',
    client_secret: '748c7dd30b4c86dd92fe7176d4a60e5d44ee405e',
  },
})
gitment.render('container')
</script>


</article>

  </div>

</body>

<foot>

    <footer class="site-footer">

  <div class="wrapper">

    <center>
        
		<p>
		 <a class="link" href="/index.html">index</a> /
		 <a class="link" href="/archive/">Archive</a> /
		 <a class="link" href="/category/">Category</a> / 
		 <a class="link" href="/tags/">Tags</a> / 
		 <a class="link" href="/about/">About</a> 
		<!--/-->
		<!--<a class="link" href="/contact/">Contact</a>-->
        </p>

        <span><script>document.write(new Date().getFullYear());</script></span>
        <span>&copy;</span>
        
		<a class="link" href="">HouXingYi</a>
		<br>
		<span>Theme &copy; <a class="link" href="https://twitter.com/itisbenjamin1" target="_blank"> Ben</a> | </span>
				<iframe
			style="margin-left: 2px; margin-bottom:-5px;"
			frameborder="0" scrolling="0" width="91px" height="20px"
			src="https://ghbtns.com/github-btn.html?user=itisbenjamin&repo=Nice_Blog&type=star&count=true" >
		</iframe>
		<br>
		<span>一共被点击<span id="busuanzi_value_site_pv"><i class="fa fa-spinner fa-pulse"></i></span>次</span>
		<span>一共访问人数<span id="busuanzi_value_site_uv"><i class="fa fa-spinner fa-pulse"></i></span>次</span>
    </center>
    
  </div>

</footer>

    <foot>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

<!-- Derictory -->

<!-- Hit analytics -->

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<!-- Directory -->

<script src="/js/jquery-1.7.2.min.js"></script>
<script src="/js/highlight.min.js"></script>
<script src="/js/main.js"></script>

</foot>


</foot>

</html>
