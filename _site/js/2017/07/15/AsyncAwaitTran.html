<!DOCTYPE html>
<html>
  <head>
      
  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

<!-- CSS -->

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="http://localhost:4000/js/2017/07/15/AsyncAwaitTran.html">
  <link rel="alternate" type="application/rss+xml" title="侯星伊的个人博客" href="http://localhost:4000/feed.xml">

<!-- Google font -->

  <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Noto Sans">

<!-- font awesome -->

<link rel="stylesheet" href="/css/font-awesome/css/font-awesome.min.css">

</head>


  

  

  </head>

  <body>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>[译]在10分钟内解释JavaScript Async/Await</title>
  <meta name="description" content="原文:https://tutorialzine.com/2017/07/javascript-async-await-explained作者:Danny Markov在很长的一段时间里，JavaScript开发者不得不依靠回调函数去处理异步代码。结果，我们大部分都经历过回调地狱和遇到这样功能的恐怖。">
</head>


  <div class="wrapper">
          <header class="post-header">

    <center><div class="post-title" itemprop="name headline">[译]在10分钟内解释JavaScript Async/Await</div>

		<div class="post-meta"><i class="fa fa-calendar-o"></i> <time datetime="15 Jul 2017" itemprop="datePublished">Jul 15 2017</time>

		&nbsp;&nbsp;•&nbsp;&nbsp;<i class="fa fa-user-secret"></i> <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span itemprop="name">HouXingYi</span>
        
		<br>
		<!--<i class="fa fa-eye"></i> <span id="busuanzi_value_page_pv"><i class="fa fa-spinner fa-pulse"></i></span>˚C</span>-->
	</div>

        
        <div class="post-tags">
        
		<a class="post-tags-item" href="http://localhost:4000/tags/">Async</a>
        
		<a class="post-tags-item" href="http://localhost:4000/tags/">Await</a>
        
		<a class="post-tags-item" href="http://localhost:4000/tags/">ES6</a>
        
	</div>
    </center>
    
</header>

<article class="post" itemscope itemtype="http://schema.org/BlogPosting">
<div class="post-content">
    <center>
	
	<p></p>
	
    </center>
	<h2>Directory</h2>
</div>

<div id="category"></div>

<div class="post-content" itemprop="articleBody">
    <div class="highlighter-rouge"><pre class="highlight"><code>原文:https://tutorialzine.com/2017/07/javascript-async-await-explained
作者:Danny Markov
</code></pre>
</div>
<p>在很长的一段时间里，JavaScript开发者不得不依靠回调函数去处理异步代码。结果，我们大部分都经历过回调地狱和遇到<a href="https://tutorialzine.com/media/2017/07/callback-hell.jpg">这样</a>功能的恐怖。</p>

<p>幸运的是，接下来（或者我们应该说 .then()）我们迎来了Promises. 他们提供了一个更组织化的回调方式，大多数社区迅速的转而使用它。</p>

<p>现在，随着最新版本的Async/Await出现，写JavaScript代码更爽了。</p>

<h2 id="什么是asyncawait">什么是Async/Await？</h2>

<p>Async/Await是一个很久就令人期待的JavaScript功能，它让使用异步函数更加愉快和容易理解。它是基于Promises的并且和现存的所有基于Promises的API相兼容。</p>

<p>从async和await这两个名字来的这两个关键字将会帮助我们整理我们的异步代码。</p>

<p>Async - 声明一个异步函数（async function someName(){…}）。</p>

<ul>
  <li>自动将一个常规函数转化为一个Promise。</li>
  <li>当调用async函数的时候，它用函数内返回的任何值来解决（resolve）。</li>
  <li>异步函数可以使用await</li>
</ul>

<p>Await-暂停执行async函数（var result = await someAsyncCall();）。</p>

<ul>
  <li>当放在一个Promise前面执行，await强制剩下的代码等待直到那个Promise结束并且返回一个结果</li>
  <li>Await只有和Promise一起使用才有用，和回调函数（普通函数）一起使用不会产生作用</li>
  <li>Await只可以在async函数内部使用</li>
</ul>

<p>这里有一个简单的例子，希望能帮你把事情理清楚：</p>

<p>假设我们想从我们的服务器中得到一些JSON文件。我们将写一个函数用axios库发送一个http GET 请求到https://tutorialzine.com/misc/files/example.json。 我们不得不等待服务器响应，所以很自然这个HTTP 请求是异步的。</p>

<p>下面我们可以看到相同的功能实现了两次。首先是用Promises，然后第二次用Async / Await。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>// Promise 实现方式
function getJSON(){

    // 为了让函数阻塞我们手动创建了一个Promise
    return new Promise( function(resolve) {
        axios.get('https://tutorialzine.com/misc/files/example.json')
            .then( function(json) {
                // 从请求来的数据可以从.then中得到
                // 我们使用resolve返回结果
                resolve(json);
            });
    });

}

// Async/Await 实现方式
// async关键字将会自动创建一个新的Promise并返回。
async function getJSONAsync(){
    // await关键词使我们免于写一个.then()
    let json = await axios.get('https://tutorialzine.com/misc/files/example.json');
    // GET请求的结果可以从json变量中得到
    // 我们把结果就像一个普通的同步函数一样返回
    return json;
}
</code></pre>
</div>

<p>很明显Async/Await版本的代码更短并且可读性更强。除了使用的语法，两个函数完全相同-他们都返回Promises并且都从axios得到JSON返回。我们可以像这样调用我们的async函数：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>getJSONAsync().then( function(result) {
    // Do something with result.
});
</code></pre>
</div>

<h2 id="那么asyncawait-让-promises-过时了吗">那么，Async/Await 让 Promises 过时了吗？</h2>

<p>一点也不，当我们使用Async/Await其实底层还是在使用Promises。对Promises的良好理解在长远考虑下是对你是十分有帮助的并且也是高度推荐的。</p>

<p>这里甚至有一些情况Async/Await不能解决而我们不得不重新去寻求Promises的帮助。一种这样的场景是我们需要去调用多个独立的异步函数并等待他们所有完成。</p>

<p>假如我们尝试用async and await，以下就会发生:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>async function getABC() {
    let A = await getValueA(); // getValueA takes 2 second to finish
    let B = await getValueB(); // getValueB takes 4 second to finish
    let C = await getValueC(); // getValueC takes 3 second to finish
    return A*B*C;
}
</code></pre>
</div>

<p>每一个await将会等待前一个返回一个结果。因为我们一次只执行一个调用那么整个函数从开始到结束将会花9秒的时间（2+4+3）。</p>

<p>这不是一个最佳的解决方案，因为A,B和C互相并不依赖。换句话来说我们在得到B的时候我们并不需要A的值。我们可以同时得到这些值以减去几秒钟的等待时间。</p>

<p>同时发送所有的requests我们需要Promise.all()。这将会保证我们在进行下一步的时候我们可以得到所有的结果，但是所有的异步函数将会平行的运行，而不是一个接一个。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>async function getABC() {
  // Promise.all() allows us to send all requests at the same time. 
  let results = await Promise.all([ getValueA, getValueB, getValueC ]); 

  return results.reduce((total,value) =&gt; total * value);
}
</code></pre>
</div>

<p>这种方式函数将会花费少的多的时间，在getValueB结束的时候getValueA和getValueC就已经结束了。我们将有效的减少执行的时间到最慢的请求而不是时间的总和。</p>

<h2 id="处理asyncawait的错误">处理Async/Await的错误</h2>

<p>另一个关于Async/Await很棒的事是它允许我们用很棒的老式try/catch块去catch任何意外的错误。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>async function doSomethingAsync(){
    try {
        // This async call may fail.
        let result = await someAsyncCall();
    }
    catch(error) {
        // If it does we will catch the error here.
    }  
}
</code></pre>
</div>

<p>任何我们写在try块中的等待的异步调用或者其他任何错误代码，catch都能解决他们引起的错误（error）。</p>

<p>如果情况需要，我们也可以在执行async函数的时候抓取错误。由于所有异步函数返回Promises，所以我们可以在调用它们时简单地包含.catch()事件处理程序。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>// 不包含try/catch块的async函数
async function doSomethingAsync(){
    // 这个async调用也许会失败
    let result = await someAsyncCall();
    return result;  
}

// 我们catch错误在调用async函数的时候
doSomethingAsync().
    .then(successHandler)
    .catch(errorHandler);
</code></pre>
</div>

<p>重要的是选择一种你喜欢的错误处理的方式，并坚持使用它。同时使用try/catch和.catch(）将很有可能导致一些问题。</p>

<h2 id="浏览器支持">浏览器支持</h2>

<p>Async/Await已经支持大部分的主流浏览器。绝大多数的厂商将会识别你的async/await代码而不需要额外的库-除了IE11.</p>

<p>Node开发者只要node8或以上就可以享受到改进的异步流。它在今年晚些时候应该会变成LTS（ Long Term Support ）版本。</p>

<p>如果这兼容性不能满足你，也有许多像Babel和TypeScript和Nodejs库asyncawait这样的JS transpiler（源码转换器）提供他们自己的跨平台版本的功能。</p>

<h2 id="结论">结论</h2>

<p>随着Async/Await ，JavaScript语言在代码可读性和易用性上向前迈进了一大步。能够编写类似于常规同步功能的异步代码将会受到JavaScript初学者和经验丰富的编程人员的赞赏。</p>


</div>

<div>
	
	<div class="eof"></div>
	
</div>

<!--先不分享-->
<!-- <div class="share">
    <p>Share this post with: </p>
	<a href="https://twitter.com/intent/tweet?text=[译]在10分钟内解释JavaScript Async/Await@&amp;url=http://localhost:4000/js/2017/07/15/AsyncAwaitTran.html" class="twitter-share">
		<span class="fa-stack fa-lg">
			<i class="fa fa-circle fa-stack-2x"></i>
			<i class="fa fa-twitter fa-stack-1x fa-inverse"></i>
		</span>
	</a>
    
	<a href="https://www.facebook.com/sharer/sharer.php?u=http://localhost:4000/js/2017/07/15/AsyncAwaitTran.html" class="facebook-share">
		<span class="fa-stack fa-lg">
			<i class="fa fa-circle fa-stack-2x"></i>
			<i class="fa fa-facebook fa-stack-1x fa-inverse"></i>
		</span>
	</a>
    
	<a href="https://plus.google.com/share?url=http://localhost:4000/js/2017/07/15/AsyncAwaitTran.html" class="googleplus-share">
		<span class="fa-stack fa-lg">
			<i class="fa fa-circle fa-stack-2x"></i>
			<i class="fa fa-google-plus fa-stack-1x fa-inverse"></i>
		</span>
	</a>
</div>
 -->

<!-- <div id="disqus_thread"></div>


 
</div>
  -->


<div id="container"></div>
<link rel="stylesheet" href="http://localhost:4000/gitment/default.css">
<script src="http://localhost:4000/gitment/gitment.browser.js"></script>
<script>
var gitment = new Gitment({
  id:window.location.pathname,
  owner: 'HouXingYi',
  repo: 'HouXingYi.github.io',
  oauth: {
    client_id: 'd8225497d80663e0c270',
    client_secret: '748c7dd30b4c86dd92fe7176d4a60e5d44ee405e',
  },
})
gitment.render('container')
</script>


</article>

  </div>

</body>

<foot>

    <footer class="site-footer">

  <div class="wrapper">

    <center>
        
		<p>
		 <a class="link" href="/index/">index</a> /
		 <a class="link" href="/archive/">Archive</a> /
		 <a class="link" href="/category/">Category</a> / 
		 <a class="link" href="/tags/">Tags</a> / 
		 <a class="link" href="/about/">About</a> 
		<!--/-->
		<!--<a class="link" href="/contact/">Contact</a>-->
        </p>

        <span><script>document.write(new Date().getFullYear());</script></span>
        <span>&copy;</span>
        
		<a class="link" href="">HouXingYi</a>
		<br>
		<span>Theme &copy; <a class="link" href="https://twitter.com/itisbenjamin1" target="_blank"> Ben</a> | </span>
				<iframe
			style="margin-left: 2px; margin-bottom:-5px;"
			frameborder="0" scrolling="0" width="91px" height="20px"
			src="https://ghbtns.com/github-btn.html?user=itisbenjamin&repo=Nice_Blog&type=star&count=true" >
		</iframe>
		<br>
		<span>一共被点击<span id="busuanzi_value_site_pv"><i class="fa fa-spinner fa-pulse"></i></span>次</span>
		<span>一共访问人数<span id="busuanzi_value_site_uv"><i class="fa fa-spinner fa-pulse"></i></span>次</span>
    </center>
    
  </div>

</footer>

    <foot>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

<!-- Derictory -->

<!-- Hit analytics -->

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<!-- Directory -->

<script src="/js/jquery-1.7.2.min.js"></script>
<script src="/js/highlight.min.js"></script>
<script src="/js/main.js"></script>

</foot>


</foot>

</html>
