<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>侯星伊的个人博客</title>
    <description>A Simple Jekyll Blog Theme. # this means to ignore newlines until &quot;baseurl:&quot;
</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Fri, 08 Dec 2017 10:30:30 +0800</pubDate>
    <lastBuildDate>Fri, 08 Dec 2017 10:30:30 +0800</lastBuildDate>
    <generator>Jekyll v3.4.3</generator>
    
      <item>
        <title>理解并使用js回调函数|性感的js</title>
        <description>&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;原文:http://javascriptissexy.com/understand-javascript-callback-functions-and-use-them
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在 JavaScript 中，函数是第一类对象；这意味着，函数是Object类型并且可以像其他对象一样（比如String，Array，Number）以第一类的方式使用，因为他们本身都是对象。他们可以“被储存进变量中，作为参数传入一个函数，在函数中被创建，并在函数中被返回”。&lt;/p&gt;

&lt;p&gt;因为函数是第一类对象，我们可以把函数作为参数传入另外一个函数并且之后可以执行传入的函数或者甚至把函数返回出来以供后面执行。这就是在 JavaScript 中使用回调函数的本质。在余下的文章中我们会学到 JavaScript 回调函数的方方面面。回调函数大概是在 JavaScript 中使用最为广泛的函数式编程技术了，你大概可以在任何JavaScript代码或者jQuery代码中看到它，然而它对许多JavaScript开发者来说还是保持神秘。当你读完这篇文章的时候，它将不再神秘了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;回调函数&lt;/strong&gt;是由一个叫做&lt;strong&gt;函数式编程&lt;/strong&gt;的编程范式而来的。最基础来说，函数式编程具体规定了把函数作为参数来使用。函数式编程曾经是-当然现在也是，不过程度有所减少-被认为是一种编程大师的特殊技巧。&lt;/p&gt;

&lt;p&gt;幸运的是，函数式编程这门技术已经被解释清楚，以至于像你我这样的普通人也可以轻而易举的理解和使用了。函数式编程中一个主要的技巧正好就是回调函数。很快你就会读到，实现一个回调函数就像传入一个普通变量作为参数那样简单。这个技巧如此简单以至于我总是惊奇它经常被放在高级JavaScript主题下。&lt;/p&gt;

&lt;h2 id=&quot;什么是回调或者高阶函数&quot;&gt;什么是回调或者高阶函数&lt;/h2&gt;

&lt;p&gt;回调函数，也被称作高阶函数，就是把一个函数作为参数传入“另一个函数”，然后回调函数在“另一个函数”中调用。回调函数本质上是一种模式（对一种问题的确定解决方案），因此使用回调函数我们也称之为回调模式。&lt;/p&gt;

&lt;p&gt;思考下面这个在jQuery中回调函数的常见用法：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//注意传入click方法的参数是一个函数，不是一个变量。
$(&quot;#btn_1&quot;).click(function() {
  alert(&quot;Btn 1 Clicked&quot;);
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在以上的例子中可以看到，我们把函数当做一个参数传给一个click方法。click方法则会调用我们传的那个回调函数。这个例子展示了一种典型的回调函数的使用，这是种在jQuery中广泛使用的方式。&lt;/p&gt;

&lt;p&gt;思考下面另一个典型的回调函数的例子：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var friends = [&quot;Mike&quot;, &quot;Stacy&quot;, &quot;Andy&quot;, &quot;Rick&quot;];

friends.forEach(function (eachName, index){
console.log(index + 1 + &quot;. &quot; + eachName); // 1\. Mike, 2\. Stacy, 3\. Andy, 4\. Rick
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;和上面一样，注意我们把一个匿名函数作为参数给 forEach 方法的这种方式。&lt;/p&gt;

&lt;p&gt;到此为止我们已经把匿名函数做为参数传给了另一个函数或方法。接下来在我们看更多具体的例子之前，让我们先来理解回调是如何工作的并开始创建我们自己的回调函数。&lt;/p&gt;

&lt;h2 id=&quot;回调函数是怎么工作的&quot;&gt;回调函数是怎么工作的&lt;/h2&gt;

&lt;p&gt;我们可以把函数像变量一样在函数中传递和返回，并在另一个函数中使用。当我们把函数作为参数传递给另一个函数，我们只是传递了函数的定义。我们没有在参数中调用函数。换句话来说，我们没有像执行函数一样带着一对括号那样传递函数。&lt;/p&gt;

&lt;p&gt;并且因为包含函数有着作为函数定义的回调函数作为参数，它就可以在任何时候调用。&lt;/p&gt;

&lt;p&gt;注意回调函数不是立即就执行。它是在包含的函数体中指定的地方“回头调用”。所以，即使第一个jQuery例子张的像这样：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//在参数中匿名函数并没有执行
$(&quot;#btn_1&quot;).click(function() {
  alert(&quot;Btn 1 Clicked&quot;);
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;那个匿名函数将会过一会在函数体中调用。即使没有命名，它也可以通过arguments对象在函数体中获得。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;回调函数是闭包&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;当我们把一个回调函数作为参数传入另一个函数，回调在包含函数体中某一个位置被调用，就好像回调是在包含函数体中被定义一样。这意味着回调是一个闭包。读我的另一个博文&lt;a href=&quot;http://javascriptissexy.com/understand-javascript-closures-with-ease/&quot;&gt;Understand JavaScript Closures With Ease&lt;/a&gt;，了解更多关于闭包的事情。众所周知，闭包可以获得包含函数的作用域，这样闭包就可以访问包含函数的内部的变量,甚至也能访问全局的变量。&lt;/p&gt;

&lt;h2 id=&quot;实现回调函数的基本原则&quot;&gt;实现回调函数的基本原则&lt;/h2&gt;

&lt;p&gt;在不复杂的情况下，回调有一些值得注意的原则在我们实现的时候需要熟悉的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;使用命名过的或匿名函数作为回调&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在先前的jQuery和forEach例子，我们使用定义在包含函数的参数中的匿名函数。这是一种经常使用模式之一。另一个流行的模式是声明一个命名函数然后将这个函数的名字作为参数。考虑以下：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 全局变量
var allUserData = [];

// 打印用logStuff函数 
function logStuff (userData) {
    if ( typeof userData === &quot;string&quot;)
    {
        console.log(userData);
    }
    else if ( typeof userData === &quot;object&quot;)
    {
        for (var item in userData) {
            console.log(item + &quot;: &quot; + userData[item]);
        }

    }

}

// 一个有两个参数的函数，最后一个参数是回调函数
function getInput (options, callback) {
    allUserData.push (options);
    callback (options);

}

// 当我们调用getInput函数的时候，我们传入logStuff作为参数
// 所以logStuff函数将会在getInput函数内部回头调用（或者说执行）
getInput ({name:&quot;Rich&quot;, speciality:&quot;JavaScript&quot;}, logStuff);
//  name: Rich
// speciality: JavaScript
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;传参给回调函数&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;因为回调函数在执行的时候就是一个正常的函数，那我们自然可以传参给它。我们可以传入任意的包含函数的内容（或者全局内容）作为参数传给回调函数。在之前的例子中，我们传options作为参数给回调函数。下面来传下全局变量和本地变量：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//全局变量
var generalLastName = &quot;Clinton&quot;;

function getInput (options, callback) {
    allUserData.push (options);
// 把全局变量generalLastName传给回调函数
    callback (generalLastName, options);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;在执行回调的时候确保它是个函数&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在调用传入的回调函数参数之前检查是否确实是一个函数总是明智的。同样，让这个回调函数可选，也是一个好的实践。&lt;/p&gt;

&lt;p&gt;让我们来重构下之前的例子中的getInput函数来保证有适当的检查。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function getInput(options, callback) {
    allUserData.push(options);

    // 确认回调是一个函数
    if (typeof callback === &quot;function&quot;) {
    // 已确认是一个函数，就可以放心的调用了
        callback(options);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;如果getInput函数在没有回调函数作为参数或用非函数代替函数传入的情况下调用的话，没有这些适当的检查，我们的代码将会报一个运行时错误。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;当使用带有this对象的方法作为回调的问题&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;当回调是一个使用this对象的方法时，我们要改变下调用回调函数的方式来保持this对象上下文。否则当回调传给一个全局函数的时候，this对象将会指向全局window对象。或者它会指向包含这个方法的对象。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 定义一个有着一些属性和方法的对象
// 过一会会把方法作为回调函数传给另一个函数
var clientData = {
    id: 094545,
    fullName: &quot;Not Set&quot;,
    // setUserName是一个在clientData对象上的方法
    setUserName: function (firstName, lastName)  {
      this.fullName = firstName + &quot; &quot; + lastName;
    }
}

function getUserInput(firstName, lastName, callback)  {
    // 在这里可以验证下firstName/lastName

    // 在这里保存名字
    callback (firstName, lastName);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在下面的例子中，当clientData.setUserName执行的时候，this.fullName将会不在clientData对象上设置fullName属性。反而，它会在window对象上设置fullName属性，原因是getUserInput是一个全局函数。而在全局函数中，this对象指向window对象。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;getUserInput (&quot;Barack&quot;, &quot;Obama&quot;, clientData.setUserName);

console.log (clientData.fullName);// Not Set

// fullName属性在window对象上被初始化了
console.log (window.fullName); // Barack Obama
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;使用Call或者Apply函数来保持this&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;我们可以通过使用_Call_或者_Apply_函数解决之前的问题 (我们将会在之后的一篇博客里讨论着两个方法)。暂时，你只需要知道在JavaScript中，每一个函数都有两个方法：Call和Apply。这两个方法用于设置函数中的_this_对象并且传入参数。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Call&lt;/strong&gt;把第一个参数的值用于函数内的_this_对象，然后剩下的参数独立地传给函数（通过逗号分隔）。&lt;strong&gt;Apply&lt;/strong&gt;函数也是把第一个参数的值用于函数内的_this_对象，然而最后一个参数是一个传给对象的数组（或者_arguments_对象）。&lt;/p&gt;

&lt;p&gt;这听起来很复杂，但是让我们来看看使用Apply或Call是多么简单。想要解决先前例子中的问题，我们将会使用Apply函数：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//注意这里我们为回调对象多加了个参数，叫做callbackObj
function getUserInput(firstName, lastName, callback, callbackObj)  {

    // 用apply函数把this指向callbackObj
    callback.apply (callbackObj, [firstName, lastName]);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;随着Apply函数正确地设置this对象，我们现在也在clientData对象上可以正确地执行回调并且正确地设置fullName属性了：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 我们传入clientData.setUserName方法和clientData对象作为参数。clientData对象将用apply函数设置this对象
getUserInput (&quot;Barack&quot;, &quot;Obama&quot;, clientData.setUserName, clientData);

// clientData上的fullName属性被正确地设置。
console.log (clientData.fullName); // Barack Obama
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;我们也可以使用Call函数，但是在这个例子中我们使用Apply函数。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;允许多个回调函数&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;我们可以传入不止一个回调函数作为函数的参数，就像我们可以传入不止一个参数。下面是一个典型jQuery AJAX函数：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function successCallback() {
    // Do stuff before send
}

function successCallback() {
    // Do stuff if success message received
}

function completeCallback() {
    // Do stuff upon completion
}

function errorCallback() {
    // Do stuff if error received
}

$.ajax({
    url:&quot;http://fiddle.jshell.net/favicon.png&quot;,
    success:successCallback,
    complete:completeCallback,
    error:errorCallback

});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;回调地狱问题和解决方案&quot;&gt;“回调地狱”问题和解决方案&lt;/h2&gt;

&lt;p&gt;进行任何顺序的异步代码执行的时候，经常会出现很多层的回调函数，在某种程度下，会像以下的代码这样。以下的这些凌乱的代码我们称之为回调地狱，因为太多层回调以至于难以理解代码。我从node-mongodb-native中找到下面的代码。&lt;strong&gt;以下的代码只是用于展示&lt;/strong&gt;：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var p_client = new Db('integration_tests_20', new Server(&quot;127.0.0.1&quot;, 27017, {}), {'pk':CustomPKFactory});
p_client.open(function(err, p_client) {
    p_client.dropDatabase(function(err, done) {
        p_client.createCollection('test_custom_key', function(err, collection) {
            collection.insert({'a':1}, function(err, docs) {
                collection.find({'_id':new ObjectID(&quot;aaaaaaaaaaaa&quot;)}, function(err, cursor) {
                    cursor.toArray(function(err, items) {
                        test.assertEquals(1, items.length);

                        // Let's close the db
                        p_client.close();
                    });
                });
            });
        });
    });
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;你可能不会经常在代码里遇到这样的问题，但你总会不时的遇见，这时候你有以下两种解决方案。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;相比于在函数的参数中定义一个匿名函数，你可以显示的声明函数并命名，然后用传递函数名的方法代替回调。&lt;/li&gt;
  &lt;li&gt;模块化：把你的代码模块化，你可以导出一部分代码做特定的事情。然后你在你更大的应用中导入这个模块。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;创建你自己的回调函数&quot;&gt;创建你自己的回调函数&lt;/h2&gt;

&lt;p&gt;现在你已经完全掌握了JavaScript回调函数的方方面面了，并且你已知道使用回调函数非常简单而强大，所以现在你现在应该着眼于你自己的代码中使用回调函数的机会，因为它会让你：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;不重复代码&lt;/li&gt;
  &lt;li&gt;更多通用的代码，实现更好的抽象&lt;/li&gt;
  &lt;li&gt;更好的可维护性&lt;/li&gt;
  &lt;li&gt;更好的可读性&lt;/li&gt;
  &lt;li&gt;更多专业的函数&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;创建你自己的回调函数是相当简单的。在下面的例子中，我本可以创建一个函数去做所有的事情：获取用户数据，用数据创建一个通用的诗歌，并且致敬用户。这将会是一个有着众多if/else语句的混乱的函数，并且即使如此它也是非常有局限性，不能够胜任应用需要用用户的数据实现的其他功能。&lt;/p&gt;

&lt;p&gt;相反，我把功能的执行交给回调函数，这样获得了数据的主函数就可以通过简单的传用户名和性别的参数给回调函数并执行回调来执行几乎任何任务。&lt;/p&gt;

&lt;p&gt;简单来说，getUserInput函数是通用的：它可以执行各种功能的回调：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
// 首先，创建通用诗歌创作函数；它将会是下面的getUserInput函数的回调函数
function genericPoemMaker(name, gender) {
    console.log(name + &quot; is finer than fine wine.&quot;);
    console.log(&quot;Altruistic and noble for the modern time.&quot;);
    console.log(&quot;Always admirably adorned with the latest style.&quot;);
    console.log(&quot;A &quot; + gender + &quot; of unfortunate tragedies who still manages a perpetual smile&quot;);
}


//最后一个参数就是回调函数，它将会是我们上面定义的genericPoemMaker
function getUserInput(firstName, lastName, gender, callback) {
    var fullName = firstName + &quot; &quot; + lastName;

    // 确认回调是函数
    if (typeof callback === &quot;function&quot;) {
    // 执行回调函数并传入参数
    callback(fullName, gender);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;调用getUserInput函数并传入genericPoemMaker函数作为回调：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;getUserInput(&quot;Michael&quot;, &quot;Fassbender&quot;, &quot;Man&quot;, genericPoemMaker);
// Output
/* Michael Fassbender is finer than fine wine.
Altruistic and noble for the modern time.
Always admirably adorned with the latest style.
A Man of unfortunate tragedies who still manages a perpetual smile.
*/
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;因为getUserInput函数只是处理获取数据，我们可传入任何的回调给它。比如，我们可以传入一个greetUser函数像下面这样：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function greetUser(customerName, sex)  {
   var salutation  = sex &amp;amp;&amp;amp; sex === &quot;Man&quot; ? &quot;Mr.&quot; : &quot;Ms.&quot;;
  console.log(&quot;Hello, &quot; + salutation + &quot; &quot; + customerName);
}

// 将greetUser函数作为回调传入getUserInput
getUserInput(&quot;Bill&quot;, &quot;Gates&quot;, &quot;Man&quot;, greetUser);

// 下面是输出
Hello, Mr. Bill Gates
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;我们像原来那样调用getUserInput函数，但是这次它执行了一个完全不同的任务。&lt;/p&gt;

&lt;p&gt;你可以看到，回调函数提供了更多的灵活。虽然先前的例子相对来说比较简单，但是想想看如果你开始使用回调函数你将会节省多少工作量，你代码的抽象程度将会多好。加油，马上用起你的回调函数。&lt;/p&gt;

&lt;p&gt;注意以下几种我们经常在JavaScript中使用回调函数的方式，特别是在开发现代web应用程序，库，和框架的时候：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;用于异步执行&lt;/li&gt;
  &lt;li&gt;在事件监听器/处理器中&lt;/li&gt;
  &lt;li&gt;在setTimeout和setInterval方法中&lt;/li&gt;
  &lt;li&gt;用于通用化：代码简洁&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;最后的话&quot;&gt;最后的话&lt;/h2&gt;

&lt;p&gt;JavaScript回调函数好用而又强大，它为你的web应用和代码带来了很多好处。当你需要的时候你就应该用回调函数；看看能不能用回调函数来提高你的代码的抽象性，可维护性和可读性。&lt;/p&gt;

&lt;h3 id=&quot;参考&quot;&gt;参考&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;http://c2.com/cgi/wiki?FirstClass&lt;/li&gt;
  &lt;li&gt;https://github.com/mongodb/node-mongodb-native&lt;/li&gt;
  &lt;li&gt;http://callbackhell.com/&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.amazon.com/gp/product/0596806752/ref=as_li_tf_tl?ie=UTF8&amp;amp;camp=1789&amp;amp;creative=9325&amp;amp;creativeASIN=0596806752&amp;amp;linkCode=as2&amp;amp;tag=interhaptic-20&quot;&gt;JavaScript Patterns&lt;/a&gt; by Stoyan Stefanov (Sep 28, 2010)&lt;/li&gt;
&lt;/ol&gt;

</description>
        <pubDate>Tue, 07 Nov 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/js/2017/11/07/callback.html</link>
        <guid isPermaLink="true">http://localhost:4000/js/2017/11/07/callback.html</guid>
        
        <category>callback</category>
        
        
        <category>js</category>
        
      </item>
    
      <item>
        <title>《深入理解ES6》之块级作用域与字符串</title>
        <description>&lt;h2 id=&quot;块级作用域绑定&quot;&gt;块级作用域绑定&lt;/h2&gt;

&lt;h3 id=&quot;使用var声明&quot;&gt;使用var声明&lt;/h3&gt;

&lt;p&gt;原来我们在js中声明变量是使用var关键字。&lt;/p&gt;

&lt;p&gt;我们都知道，使用var声明变量，会有变量提升，比如下面的代码：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;console.log(value); //undefined
var value = 0;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;通知台会打印undefined，实际JavaScript引擎将代码理解成下面这样：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var value;
console.log(value); //undefined
value = 0;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;所有的变量的声明都会被提升至函数的顶部。&lt;/p&gt;

&lt;p&gt;另一个使用var声明的特点是，var声明的变量作用域是函数作用域。&lt;/p&gt;

&lt;h3 id=&quot;块级声明&quot;&gt;块级声明&lt;/h3&gt;

&lt;p&gt;ES6引入了块级声明，具体有let声明和const声明。&lt;/p&gt;

&lt;p&gt;let声明的用法与var相同，区别有如下：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;不会变量提升&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;用let声明变量，在变量声明之前是不可以使用的，若使用则会报错。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;console.log(value); //ReferenceError: value is not defined
let value = 0;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;块级作用域&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;用let声明的变量，作用的范围在{}之中，执行流离开{}变量就会销毁。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;禁止重声明&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;var重复声明则后面的会覆盖前面的，let重复声明则会报错。&lt;/p&gt;

&lt;p&gt;const声明的行为类似于let，但const定义的为常量，不可在使用过程中修改。&lt;/p&gt;

&lt;p&gt;但是，有一点要注意，js中的常量如果是对象，则对象的值可以修改。这一点与其他语言中的常量有所不同。&lt;/p&gt;

&lt;h2 id=&quot;循环中的块作用域&quot;&gt;循环中的块作用域&lt;/h2&gt;

&lt;p&gt;js编程中的一个经典问题如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var funcs = [];

for(var i = 0; i &amp;lt; 10; i++){
    funcs.push(function(){
        console.log(i);
    });
}

funcs.forEach(function(func){
    func(); //输出10次数字10
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这个问题的原因是js并不像我们想象的那样运行，我们希望每次的i都是独立的i，每次打印当前循环阶段的i。&lt;/p&gt;

&lt;p&gt;而实际情况是，所有的i都是共享的，而在循环结束的时候，i的值为10。传入的回调函数作为闭包可以访问i的值，但当调用的时候，i已经变成10了。所以每次调用打印的都是10。&lt;/p&gt;

&lt;p&gt;通常解决这个问题我们都是采用立即调用函数表达式（IIFE）。如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var funcs = [];

for(var i = 0; i &amp;lt; 10; i++){
    funcs.push((function(value){
        return function(){
            console.log(value);
        }
    }(i)));
}

funcs.forEach(function(func){
    func(); //输出0，然后是1、2直到9
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;既丑陋又难以理解。&lt;/p&gt;

&lt;p&gt;而使用let在循环中声明变量就简单多了：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var funcs = [];

for(let i = 0; i &amp;lt; 10; i++){
    funcs.push(function(){
        console.log(i);
    });
}

funcs.forEach(function(func){
    func(); //输出0，然后是1、2直到9
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这种结果符合我们理解的期望。每次循环的时候let声明都会创建一个新变量i，并将其初始化为i的当前值。&lt;/p&gt;

&lt;p&gt;需要注意的是，let声明在循环中的这种行为是专门定义的，与let的不提升特性无关。&lt;/p&gt;

&lt;p&gt;而const声明可以在for-in和for-of中使用，但是若在for循环中，出现i++等修改常量的行为则会报错。&lt;/p&gt;

&lt;h2 id=&quot;字符串&quot;&gt;字符串&lt;/h2&gt;

&lt;h3 id=&quot;模板字面量&quot;&gt;模板字面量&lt;/h3&gt;

&lt;p&gt;模板字面量是ES6中一个重要的新增特性，主要有下面这些能力：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;多行字符串&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;模板字面量可以轻易的创建多行字符串：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let message = `Multiline
string`;

console.log(message);            //&quot;Multiline
                                 // string&quot;
console.log(message.length);     //16
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;字符串占位符&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在一个模板字面量中，你可以把任何合法的JavaScript表达式嵌入到占位符中并将其作为字符串的一部分输出到结果中。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let name = &quot;Nicholas&quot;,
    message = `Hello, ${name}.`;

console.log(message);        //&quot;Hello,Nicholas.&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;还可以嵌入如运算式、函数调用等JavaScript表达式&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let count = 10,
    price = 0.25,
    message = `${count} items cost $${(count * price).toFixed(2)}.`;

console.log(message);                //&quot;10 items cost $2.50.&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;还可以在一个模板字面量里面嵌入另外一个模板字面量&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let name = &quot;Nicholas&quot;,
    message = `Hello, ${
        `my name is ${ name }`
    }.`;

console.log(message);        //&quot;Hello,my name is Nicholas.&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;标签模板&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;模板标签可以执行模板字面量上的转换并返回最终的字符串值。等于可以自定义字符串组合的方式。标签指的是在模板字面量第一个反撇号(`)前方标注的字符串。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function passthru(literals,...substitutions){
    let result = &quot;&quot;;

    //根据substitution的数量来确定循环的执行次数
    for(let i = 0; i &amp;lt; substitutions.length; i++){

        result += literals[i];
        result += substitutions[i];

    }

    //合并最后一个literal
    result += literals[literals.length - 1];

    return result;

}

let count = 10,
    price = 0.25,
    message = passthru`${count} items cost $${(count * price).toFixed(2)}.`

console.log(message);        //&quot;10 items cost $2.50.&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
        <pubDate>Sun, 05 Nov 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/js/2017/11/05/ES6-1.html</link>
        <guid isPermaLink="true">http://localhost:4000/js/2017/11/05/ES6-1.html</guid>
        
        <category>ES6</category>
        
        
        <category>js</category>
        
      </item>
    
      <item>
        <title>js异步编程解决方案</title>
        <description>&lt;p&gt;在JavaScript中，函数作为一等公民，使用上非常自由，无论调用，或者作为参数，或者作为返回值均可。&lt;/p&gt;

&lt;p&gt;于是在无论是前端的事件驱动回调函数中，还是在nodejs中的异步IO，我们可以看见大量的回调函数。所谓的回调函数，就是把函数作为参数传入，并在将来的某个时候”回头调用”。&lt;/p&gt;

&lt;p&gt;回调函数通常作为异步编程的一个解决方案，但是回调函数有许多问题&lt;/p&gt;

&lt;h2 id=&quot;回调函数的问题&quot;&gt;回调函数的问题&lt;/h2&gt;

&lt;h3 id=&quot;问题一回调地狱&quot;&gt;问题一：回调地狱&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var fs = require('fs');
fs.readFile('./text1.txt', 'utf8', function(err, data){
    console.log(&quot;text1 file content: &quot; + data);
    fs.readFile('./text2.txt', 'utf8', function(err, data){
        console.log(&quot;text2 file content: &quot; + data);
    });
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;上面是我们在进行nodejs编程的时候经常会遇见的场景。前端进行异步请求的时候也经常会遇见这样的场景。当回调嵌套过深的时候，就会出现以下场景。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;doSomethingAsync1(function(){
    doSomethingAsync2(function(){
        doSomethingAsync3(function(){
            doSomethingAsync4(function(){
               doSomethingAsync5(function(){
                    // code...
                });
            });
        });
    });
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;所以这种嵌套过深的情况有时候是不可忍受的，我们称之为“回调地狱”或“回调金字塔”&lt;/p&gt;

&lt;h3 id=&quot;问题二异步编程的理解&quot;&gt;问题二：异步编程的理解&lt;/h3&gt;

&lt;p&gt;我们的大脑习惯顺序思考问题，当要做一件事情的时候，我们会思考先做A再做B然后做C…。然而用回调函数写的异步代码则违反了我们天生的思考原则。&lt;/p&gt;

&lt;p&gt;你能够很快的说出以下代码的执行顺序吗。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;doA(function(){
    doC();

    doD(function(){
        doF();
    })

    doE();
})

doB();
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;对于这样的代码，我们需要很大的努力才可以理解。也就是说，可读性很差。&lt;/p&gt;

&lt;h2 id=&quot;回调函数的代替解决方案&quot;&gt;回调函数的代替解决方案&lt;/h2&gt;

&lt;h3 id=&quot;拆解function&quot;&gt;拆解function&lt;/h3&gt;

&lt;p&gt;我们可以通过将各部分的任务拆解为单个函数&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function getData(count) {
    get(`/sampleget?count=${count}`, data =&amp;gt; {
        console.log(data);
    });
}

function queryDB(kw) {
    db.find(`select * from sample where kw = ${kw}`, (err, res) =&amp;gt; {
        getData(res.length);
    });
}

function readFile(filepath) {
    fs.readFile(filepath, 'utf-8', (err, content) =&amp;gt; {
        let keyword = content.substring(0, 5);
        queryDB(keyword);
    });
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;事件发布订阅模式&quot;&gt;事件发布/订阅模式&lt;/h3&gt;

&lt;p&gt;采用发布订阅模式进行解耦&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;const events = require('events');
const eventEmitter = new events.EventEmitter();

eventEmitter.on('db', (err, kw) =&amp;gt; {
    db.find(`select * from sample where kw = ${kw}`, (err, res) =&amp;gt; {
        eventEmitter('get', res.length);
    });
});

eventEmitter.on('get', (err, count) =&amp;gt; {
    get(`/sampleget?count=${count}`, data =&amp;gt; {
        console.log(data);
    });
});

fs.readFile('./sample.txt', 'utf-8', (err, content) =&amp;gt; {
    let keyword = content.substring(0, 5);
    eventEmitter. emit('db', keyword);
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;以上两种解决方案确实可以解决一定问题，但终究没有摆脱回调函数的模式。&lt;/p&gt;

&lt;h3 id=&quot;promise&quot;&gt;Promise&lt;/h3&gt;

&lt;p&gt;ES 6中原生提供了Promise对象，Promise对象代表了某个未来才会知道结果的事件(一般是一个异步操作)，并且这个事件对外提供了统一的API，可供进一步处理。&lt;/p&gt;

&lt;p&gt;使用Promise对象可以用同步操作的流程写法来表达异步操作，避免了层层嵌套的异步回调，代码也更加清晰易懂，方便维护。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var fs = require('fs')
var read = function (filename){
    var promise = new Promise(function(resolve, reject){
        fs.readFile(filename, 'utf8', function(err, data){
            if (err){
                reject(err);
            }
            resolve(data);
        })
    });
    return promise;
}
read('./text1.txt')
.then(function(data){
    console.log(data);
return read('./text2.txt');
})
.then(function(data){
    console.log(data);
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;h3 id=&quot;generator&quot;&gt;Generator&lt;/h3&gt;

&lt;p&gt;Generator 函数有多种理解角度。语法上，首先可以把它理解成，Generator 函数是一个状态机，封装了多个内部状态。&lt;/p&gt;

&lt;p&gt;执行 Generator 函数会返回一个遍历器对象，也就是说，Generator 函数除了状态机，还是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历 Generator 函数内部的每一个状态。&lt;/p&gt;

&lt;p&gt;形式上，Generator 函数是一个普通函数，但是有两个特征。一是，function关键字与函数名之间有一个星号；二是，函数体内部使用yield表达式，定义不同的内部状态（yield在英语里的意思就是“产出”）。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function* helloWorldGenerator() {
  yield 'hello';
  yield 'world';
  yield 'end';
  return 'ending';
}
hw.next()
// { value: 'hello', done: false }

hw.next()
// { value: 'world', done: false }

hw.next()
// { value: 'end', done: true }

hw.next()
// { value: undefined, done: true }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;上面代码定义了一个 Generator 函数helloWorldGenerator，它内部有三个yield表达式（hello和world、end），即该函数有三个状态：hello，world，end 和 return 语句（结束执行）。&lt;/p&gt;

&lt;p&gt;然后，Generator 函数的调用方法与普通函数一样，也是在函数名后面加上一对圆括号。不同的是，调用 Generator 函数后，该&lt;code class=&quot;highlighter-rouge&quot;&gt;函数并不执行&lt;/code&gt;，返回的也不是函数运行结果，而是一个指向内部状态的指针对象，也就是遍历器对象（Iterator Object）。&lt;/p&gt;

&lt;p&gt;下一步，必须调用遍历器对象的next方法，使得指针移向下一个状态。也就是说，每次调用next方法，内部指针就从函数头部或上一次停下来的地方开始执行，直到遇到下一个yield表达式（或return语句）为止。换言之，Generator 函数是分段执行的，yield表达式是暂停执行的标记，而next方法可以恢复执行。&lt;/p&gt;

&lt;h2 id=&quot;asyncawait&quot;&gt;async/await&lt;/h2&gt;

&lt;p&gt;async/await是ES7中的异步解决方案，可以看我的这篇博文。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://houxingyi.github.io/js/2017/07/15/AsyncAwaitTran.html&quot;&gt;[译]在10分钟内解释JavaScript Async/Await&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;结尾&quot;&gt;结尾&lt;/h2&gt;

&lt;p&gt;结合以上，我们可以有五种方法来解决回调地狱的问题&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;拆解function&lt;/li&gt;
  &lt;li&gt;事件发布/订阅模式&lt;/li&gt;
  &lt;li&gt;Promise&lt;/li&gt;
  &lt;li&gt;Generator&lt;/li&gt;
  &lt;li&gt;async/await&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Thu, 02 Nov 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/js/2017/11/02/async.html</link>
        <guid isPermaLink="true">http://localhost:4000/js/2017/11/02/async.html</guid>
        
        <category>异步编程</category>
        
        
        <category>js</category>
        
      </item>
    
      <item>
        <title>mongoose之Population</title>
        <description>&lt;p&gt;在MongoDB中没有关系型数据库的join特性，所以在document进行相互关联的时候就比较麻烦。&lt;/p&gt;

&lt;p&gt;在mongoose中有一个&lt;code class=&quot;highlighter-rouge&quot;&gt;population&lt;/code&gt;用于解决这类问题。在定义&lt;code class=&quot;highlighter-rouge&quot;&gt;Schema&lt;/code&gt;的时候，如果设置某个&lt;code class=&quot;highlighter-rouge&quot;&gt;field&lt;/code&gt;关联另一个&lt;code class=&quot;highlighter-rouge&quot;&gt;Schema&lt;/code&gt;，那么在获取&lt;code class=&quot;highlighter-rouge&quot;&gt;document&lt;/code&gt;的时候就可以使用&lt;code class=&quot;highlighter-rouge&quot;&gt;Population&lt;/code&gt;功能通过关联&lt;code class=&quot;highlighter-rouge&quot;&gt;Schema&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;field&lt;/code&gt;找到关联的另一个&lt;code class=&quot;highlighter-rouge&quot;&gt;document&lt;/code&gt;，并且用被关联&lt;code class=&quot;highlighter-rouge&quot;&gt;document&lt;/code&gt;的内容替换掉原来关联&lt;code class=&quot;highlighter-rouge&quot;&gt;field&lt;/code&gt;的内容。&lt;/p&gt;

&lt;h2 id=&quot;例子&quot;&gt;例子&lt;/h2&gt;

&lt;p&gt;下面我拿官方的例子来说明&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var mongoose = require('mongoose');
var Schema = mongoose.Schema;

var personSchema = Schema({
  _id: Schema.Types.ObjectId,
  name: String,
  age: Number,
  stories: [{ type: Schema.Types.ObjectId, ref: 'Story' }]
});

var storySchema = Schema({
  author: { type: Schema.Types.ObjectId, ref: 'Person' },
  title: String,
  fans: [{ type: Schema.Types.ObjectId, ref: 'Person' }]
});

var Story = mongoose.model('Story', storySchema);
var Person = mongoose.model('Person', personSchema);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;首先先定义两个model，并且这两个model的schema相互引用。可以看到在person的stories字段（field ）中我们定义了数组，表示关联的数据解析为数组。其中ref选项告诉mongoose在使用populate的时候使用什么model，并且后续所有的传入的_id都要在这个model之中。&lt;/p&gt;

&lt;h2 id=&quot;保存数据&quot;&gt;保存数据&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var author = new Person({
  _id: new mongoose.Types.ObjectId(),
  name: 'Ian Fleming',
  age: 50
});

author.save(function (err) {
  if (err) return handleError(err);
  
  var story1 = new Story({
    title: 'Casino Royale',
    author: author._id    // assign the _id from the person
  });
  
  story1.save(function (err) {
    if (err) return handleError(err);
    // thats it!
  });
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;保存数据的时候并没有什么不同，只是记得要分配下_id，若是_ids,则把所有需要展现的document的_id做成一个数组传入。&lt;/p&gt;

&lt;h2 id=&quot;解析出引用&quot;&gt;解析出引用&lt;/h2&gt;

&lt;p&gt;上面做的一些操作并没有什么特别的，但接下来我们可以看到通过populate我们解析除了内嵌的关联document。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Story.
  findOne({ title: 'Casino Royale' }).
  populate('author').
  exec(function (err, story) {
    if (err) return handleError(err);
    console.log('The author is %s', story.author.name);
    // prints &quot;The author is Ian Fleming&quot;
  });
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;下面我说下populate方法的常用用法&lt;/p&gt;

&lt;h2 id=&quot;querypopulate&quot;&gt;Query#populate&lt;/h2&gt;

&lt;p&gt;就是查询语句之后可以调用populate&lt;/p&gt;

&lt;p&gt;语法&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;**`Query.populate(path, [select], [model], [match], [options])`**
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;参数&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;path&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;类型：&lt;code class=&quot;highlighter-rouge&quot;&gt;String&lt;/code&gt;或&lt;code class=&quot;highlighter-rouge&quot;&gt;Object&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;String类型的时， 指定要填充的关联字段，要填充多个关联字段可以以空格分隔。&lt;/p&gt;

&lt;p&gt;Object类型的时，就是把 populate 的参数封装到一个对象里。当然也可以是个数组。下面的例子中将会实现。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;select&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;类型：&lt;code class=&quot;highlighter-rouge&quot;&gt;Object&lt;/code&gt;或&lt;code class=&quot;highlighter-rouge&quot;&gt;String&lt;/code&gt;，可选，指定填充 document 中的哪些字段。&lt;/p&gt;

&lt;p&gt;Object类型的时，格式如:{name: 1, _id: 0},为0表示不填充，为1时表示填充。
　　
String类型的时，格式如:”name -_id”，用空格分隔字段，在字段名前加上-表示不填充。详细语法介绍 query-select&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;model&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;类型：Model，可选，指定关联字段的 model，如果没有指定就会使用Schema的ref。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;match&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;类型：Object，可选，指定附加的查询条件。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;options&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;类型：Object，可选，指定附加的其他查询选项，如排序以及条数限制等等。&lt;/p&gt;

&lt;p&gt;例子&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//填充所有 users 的 posts
User.find()
    .populate('posts', 'title', null, {sort: { title: -1 }})
    .exec(function(err, docs) {
        console.log(docs[0].posts[0].title); // post-by-aikin
    });

//填充 user 'luajin'的 posts
User.findOne({name: 'luajin'})
    .populate({path: 'posts', select: { title: 1 }, options: {sort: { title: -1 }}})
    .exec(function(err, doc) {
        console.log(doc.posts[0].title);  // post-by-luajin
    });

//这里的 populate 方法传入的参数形式不同，其实实现的功能是一样的，只是表示形式不一样。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;modelpopulate&quot;&gt;Model#populate&lt;/h2&gt;

&lt;p&gt;model直接调用populate&lt;/p&gt;

&lt;p&gt;语法&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;**`Model.populate(docs, options, [cb(err,doc)])`**
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;参数&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;docs&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;类型：Document或Array。单个需要被填充的 doucment 或者 document 的数组。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;options&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;类型：Object。以键值对的形式表示。&lt;/p&gt;

&lt;p&gt;keys：path select match model options，这些键对应值的类型和功能，与上述Query#populate方法的参数相同。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;[cb(err,doc)]&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;类型：Function，回调函数，接收两个参数，错误err和填充完的doc(s)。&lt;/p&gt;

&lt;p&gt;例子&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Post.find({title: 'post-by-aikin'})
    .populate('poster comments')
    .exec(function(err, docs) {

        var opts = [{
            path   : 'comments.commenter',
            select : 'name',
            model  : 'User'
        }];

        Post.populate(docs, opts, function(err, populatedDocs) {
            console.log(populatedDocs[0].poster.name);                  // aikin
            console.log(populatedDocs[0].comments[0].commenter.name);  // luna
        });
    });
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;documentpopulate&quot;&gt;Document#populate&lt;/h2&gt;

&lt;p&gt;document直接调用populate&lt;/p&gt;

&lt;p&gt;语法&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;**`Document.populate([path], [callback])`**
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;参数&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;path&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;类型：String或Object。与上述Query#populate`方法的 path 参数相同。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;callback&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;类型：Function。回调函数，接收两个参数，错误err和填充完的doc(s)。&lt;/p&gt;

&lt;p&gt;例子&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;User.findOne({name: 'aikin'})
    .exec(function(err, doc) {

        var opts = [{
            path   : 'posts',
            select : 'title'
        }];

        doc.populate(opts, function(err, populatedDoc) {
            console.log(populatedDoc.posts[0].title);  // post-by-aikin
        });
    });
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;跨越等级的populate&quot;&gt;跨越等级的Populate&lt;/h2&gt;

&lt;p&gt;populate可以进行多重引用&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var userSchema = new Schema({
  name: String,
  friends: [{ type: ObjectId, ref: 'User' }]
});

User.
  findOne({ name: 'Val' }).
  populate({
    path: 'friends',
    // Get friends of friends - populate the 'friends' array for every friend
    populate: { path: 'friends' }
  });
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;参考&quot;&gt;参考&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;http://mongoosejs.com/docs/populate.html&quot;&gt;官方starter&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000002727265&quot;&gt;Mongoose 之 Population 使用&lt;/a&gt;&lt;/p&gt;

</description>
        <pubDate>Mon, 30 Oct 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/mongodb/2017/10/30/populate.html</link>
        <guid isPermaLink="true">http://localhost:4000/mongodb/2017/10/30/populate.html</guid>
        
        <category>mongoose</category>
        
        <category>populate</category>
        
        
        <category>mongoDB</category>
        
      </item>
    
      <item>
        <title>用Vuex来做vue应用的状态管理</title>
        <description>&lt;h2 id=&quot;什么是vuex&quot;&gt;什么是Vuex&lt;/h2&gt;

&lt;p&gt;Vuex是一个专为Vue.js应用程序开发的状态管理模式。&lt;/p&gt;

&lt;p&gt;当我们的Vue应用越来越大的时候，有一些公用部分的状态不好管理，比如多重组件嵌套等。这时候，我们就可以用Vuex来进行统一的应用状态管理。&lt;/p&gt;

&lt;h2 id=&quot;核心概念&quot;&gt;核心概念&lt;/h2&gt;

&lt;h3 id=&quot;state-读&quot;&gt;State (读)&lt;/h3&gt;

&lt;p&gt;State是唯一的数据源，单一状态树&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;this.$store.state.count&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;mutations-写&quot;&gt;Mutations (写)&lt;/h3&gt;
&lt;p&gt;更改Vuex的store中的状态的&lt;code class=&quot;highlighter-rouge&quot;&gt;唯一方法&lt;/code&gt;是提交mutation,Mutation 必须是同步函数。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mutations: {
  increment (state, payload) {
    state.count += payload.amount
  }
}
store.commit('increment', {
  amount: 10
})
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;actions&quot;&gt;Actions&lt;/h3&gt;
&lt;p&gt;Action 类似于 mutation，不同在于:Action提交的是mutation，而不是直接变更状态,Action可以包含任意异步操作&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;const store = new Vuex.Store({
  state: {
    count: 0
  },
  mutations: {
    increment (state) {
      state.count++
    }
  },
  actions: {
    increment (context) {
      context.commit('increment')
    }
  }
})
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;getters&quot;&gt;Getters&lt;/h3&gt;
&lt;p&gt;通过Getters可以派生出一些新的状态（在state的基础上）&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;const store = new Vuex.Store({
  state: {
    todos: [
      { id: 1, text: '...', done: true },
      { id: 2, text: '...', done: false }
    ]
  },
  getters: {
    doneTodos: state =&amp;gt; {
      return state.todos.filter(todo =&amp;gt; todo.done)
    }
  }
})
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;modules&quot;&gt;Modules&lt;/h3&gt;
&lt;p&gt;面对复杂的应用程序，当管理的状态比较多时，我们需要将Vuex的store对象分割成模块(modules)。&lt;/p&gt;

&lt;h2 id=&quot;例子&quot;&gt;例子&lt;/h2&gt;

&lt;p&gt;你可以通过 store.state 来获取状态对象，以及通过 store.commit 方法触发状态变更。&lt;/p&gt;

&lt;p&gt;最主要的是store是全局的&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Vue.use(Vuex);

const store = new Vuex.Store({
  state: {
    count: 0
  },
  mutations: {
  	increment: state =&amp;gt; state.count++,
    decrement: state =&amp;gt; state.count--
  }
})

new Vue({
  el: '#app',
  computed: {
    count () {
	    return store.state.count
    }
  },
  methods: {
    increment () {
      store.commit('increment')
    },
    decrement () {
    	store.commit('decrement')
    }
  }
})
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
        <pubDate>Sun, 29 Oct 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/vue/2017/10/29/vuex.html</link>
        <guid isPermaLink="true">http://localhost:4000/vue/2017/10/29/vuex.html</guid>
        
        <category>vuex</category>
        
        
        <category>vue</category>
        
      </item>
    
      <item>
        <title>mongoDB常用操作</title>
        <description>&lt;p&gt;一些mongoDB常用的操作&lt;/p&gt;

&lt;h2 id=&quot;基本概念&quot;&gt;基本概念&lt;/h2&gt;

&lt;p&gt;mongoDB中的一些基本概念与SQL的基本概念是不同的，这是我们学习mongoDB的时候需要注意与区分的。 &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;下面一个表格带我们来理解下mongoDB中的一些概念。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;SQL概念&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;mongoDB概念&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;说明&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;database&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;database&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;数据库&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;table&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;collection&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;数据库表/集合&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;row&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;document&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;数据记录行/文档&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;column&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;field&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;数据字段/域&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;index&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;index&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;索引&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;table joins&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;表连接，mongoDB不支持&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;primary key&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;primary key&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;主键，mongoDB自动将_id字段设置为主键&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;通过下图，更加直观的理解mongoDB的一些概念&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;./show.png&quot; alt=&quot;展示&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;数据库&quot;&gt;数据库&lt;/h3&gt;

&lt;p&gt;一个mongoDB可以建立多个数据库&lt;/p&gt;

&lt;p&gt;通过命令show dbs来展现当前有多少数据库，名字分别叫什么&lt;/p&gt;

&lt;h3 id=&quot;文档document&quot;&gt;文档（document）&lt;/h3&gt;

&lt;p&gt;在mongoDB中文档就是一组键值对(key-value)。MongoDB 的文档不需要设置相同的字段，并且相同的字段不需要相同的数据类型，这与关系型数据库有很大的区别，也是 MongoDB 非常突出的特点。&lt;/p&gt;

&lt;p&gt;需要注意的点&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;文档中的键/值对是有序的。&lt;/li&gt;
  &lt;li&gt;文档中的值不仅可以是在双引号里面的字符串，还可以是其他几种数据类型（甚至可以是整个嵌入的文档)。&lt;/li&gt;
  &lt;li&gt;MongoDB区分类型和大小写。&lt;/li&gt;
  &lt;li&gt;MongoDB的文档不能有重复的键。&lt;/li&gt;
  &lt;li&gt;文档的键是字符串。除了少数例外情况，键可以使用任意UTF-8字符。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;集合collection&quot;&gt;集合（collection）&lt;/h3&gt;

&lt;p&gt;集合就是mongoDB文档组，类似关系型数据库中的表。一个数据库中有多个集合，可以用命令show collections来查看。集合没有固定的结构，这意味着你在对集合可以插入不同格式和类型的数据，但通常情况下我们插入集合的数据都会有一定的关联性。&lt;/p&gt;

&lt;h3 id=&quot;mongodb-数据类型&quot;&gt;MongoDB 数据类型&lt;/h3&gt;

&lt;p&gt;下表为MongoDB中常用的几种数据类型。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;SQL概念&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;mongoDB概念&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;String&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;字符串。存储数据常用的数据类型。在 MongoDB 中，UTF-8 编码的字符串才是合法的。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Integer&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;整型数值。用于存储数值。根据你所采用的服务器，可分为 32 位或 64 位。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Boolean&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;布尔值。用于存储布尔值（真/假）。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Double&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;双精度浮点值。用于存储浮点值。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Min/Max keys&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;将一个值与 BSON（二进制的 JSON）元素的最低值和最高值相对比。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Array&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;用于将数组或列表或多个值存储为一个键。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Timestamp&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;时间戳。记录文档修改或添加的具体时间。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Object&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;用于内嵌文档。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Null&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;用于创建空值。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Symbol&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;符号。该数据类型基本上等同于字符串类型，但不同的是，它一般用于采用特殊符号类型的语言。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Date&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;日期时间。用 UNIX 时间格式来存储当前日期或时间。你可以指定自己的日期时间：创建 Date 对象，传入年月日信息。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Object ID&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;对象 ID。用于创建文档的 ID。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Binary Data&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;二进制数据。用于存储二进制数据。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Code&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;代码类型。用于在文档中存储 JavaScript 代码。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Regular expression&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;正则表达式类型。用于存储正则表达式。&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;创建数据库&quot;&gt;创建数据库&lt;/h2&gt;

&lt;p&gt;直接使用use命令创建数据库。如果数据库不存在，则创建数据库，否则切换到指定数据库。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;use DATABASE_NAME
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;使用show dbs展示当前已创建的数据库。&lt;/p&gt;

&lt;p&gt;use数据库之后db命令表示当前数据库&lt;/p&gt;

&lt;h2 id=&quot;删除数据库&quot;&gt;删除数据库&lt;/h2&gt;

&lt;p&gt;使用下列命令删除数据库&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;db.dropDatabase()
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;使用下列命令删除集合&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;db.collection.drop()
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;插入数据&quot;&gt;插入数据&lt;/h2&gt;

&lt;p&gt;MongoDB 使用 insert() 或 save() 方法向集合中插入文档，语法如下：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;db.COLLECTION_NAME.insert(document)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;document采用json语法&lt;/p&gt;

&lt;p&gt;3.2 版本后还有以下几种语法可用于插入文档:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;db.collection.insertOne():向指定集合中插入一条文档数据&lt;/li&gt;
  &lt;li&gt;db.collection.insertMany():向指定集合中插入多条文档数据&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;更新文档&quot;&gt;更新文档&lt;/h2&gt;

&lt;p&gt;update() 方法用于更新已存在的文档。语法格式如下：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;db.collection.update(
   &amp;lt;query&amp;gt;,
   &amp;lt;update&amp;gt;,
   {
     upsert: &amp;lt;boolean&amp;gt;,
     multi: &amp;lt;boolean&amp;gt;,
     writeConcern: &amp;lt;document&amp;gt;
   }
)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;参数说明：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;query : update的查询条件，类似sql update查询内where后面的。&lt;/li&gt;
  &lt;li&gt;update : update的对象和一些更新的操作符（如$,$inc…）等，也可以理解为sql update查询内set后面的&lt;/li&gt;
  &lt;li&gt;upsert : 可选，这个参数的意思是，如果不存在update的记录，是否插入objNew,true为插入，默认是false，不插入。&lt;/li&gt;
  &lt;li&gt;multi : 可选，mongodb 默认是false,只更新找到的第一条记录，如果这个参数为true,就把按条件查出来多条记录全部更新。&lt;/li&gt;
  &lt;li&gt;writeConcern :可选，抛出异常的级别。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;删除文档&quot;&gt;删除文档&lt;/h2&gt;

&lt;p&gt;remove() 方法的基本语法格式如下所示：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;db.collection.remove(
   &amp;lt;query&amp;gt;,
   &amp;lt;justOne&amp;gt;
)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;如果你的 MongoDB 是 2.6 版本以后的，语法格式如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;db.collection.remove(
   &amp;lt;query&amp;gt;,
   {
     justOne: &amp;lt;boolean&amp;gt;,
     writeConcern: &amp;lt;document&amp;gt;
   }
)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;参数说明：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;query :（可选）删除的文档的条件。&lt;/li&gt;
  &lt;li&gt;justOne : （可选）如果设为 true 或 1，则只删除一个文档。&lt;/li&gt;
  &lt;li&gt;writeConcern :（可选）抛出异常的级别。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;另：&lt;/p&gt;

&lt;p&gt;remove() 方法已经过时了，现在官方推荐使用 deleteOne() 和 deleteMany() 方法。&lt;/p&gt;

&lt;h2 id=&quot;查询文档&quot;&gt;查询文档&lt;/h2&gt;

&lt;p&gt;MongoDB 查询数据的语法格式如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;db.collection.find(query, projection)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;query ：可选，使用查询操作符指定查询条件&lt;/li&gt;
  &lt;li&gt;projection ：可选，使用投影操作符指定返回的键。查询时返回文档中所有键值， 只需省略该参数即可（默认省略）。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如果你需要以易读的方式来读取数据，可以使用 pretty() 方法，语法格式如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;db.col.find().pretty()
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;pretty() 方法以格式化的方式来显示所有文档。&lt;/p&gt;

&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;

&lt;p&gt;以上是一些最基本的mongoDB的常用操作，若想看一些详情的文档和功能可以看官方的文档和一些教程。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;参考&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://docs.mongodb.com/?_ga=2.76410965.1778730410.1511524353-1232494664.1511524353&quot;&gt;mongoDB官方文档&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.runoob.com/mongodb/mongodb-tutorial.html&quot;&gt;mongoDB教程&lt;/a&gt;&lt;/p&gt;

</description>
        <pubDate>Sat, 21 Oct 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/mongodb/2017/10/21/mongo.html</link>
        <guid isPermaLink="true">http://localhost:4000/mongodb/2017/10/21/mongo.html</guid>
        
        <category>mongo</category>
        
        
        <category>mongoDB</category>
        
      </item>
    
      <item>
        <title>mongoose基础</title>
        <description>&lt;p&gt;在Nodejs开发中，我们一般使用mongoose来操作mongoDB数据库。下面我么来学习下mongoose常用的用法。&lt;/p&gt;

&lt;h2 id=&quot;准备工作&quot;&gt;准备工作&lt;/h2&gt;

&lt;p&gt;那要使用它，首先你得装上node.js和mongodb并启动mongodb数据库 &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;Github地址：https://github.com/Automattic/mongoose &lt;br /&gt;
API Docs：http://mongoosejs.com/docs/guide.html&lt;/p&gt;

&lt;h2 id=&quot;概念理解&quot;&gt;概念理解&lt;/h2&gt;

&lt;p&gt;要学习mongoose首先要了解三个重要的概念，他们是Schema、Model、Document。它们的关系是Schema生成Model、Model创造Document。 &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;Schema类似于定义表结构，但并不完全准确。它用于创建表时的数据定义(不仅仅可以定义文档的结构和属性，还可以定义文档的实例方法、静态模型方法、复合索引等)，每个Schema会映射到mongodb中的一个collection。Schema不具备操作数据库的能力，主要用于定义结构。 &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;Model是由Schema编译而成的构造器，具有抽象属性和行为，可以对数据库进行增删查改。Model所能增删查改的具体值是由Schema定义的，Schema定义以外的值则没有效果。在mongoDB中一个数据库有多个collections（由Schema定义结构），而每个collections有多个document（类似js对象一般的键值对）。&lt;/p&gt;

&lt;p&gt;Model的每一个实例（instance）就是一个文档document。Document是由Model创建的实体，它的操作也会影响数据库。&lt;/p&gt;

&lt;h2 id=&quot;连接数据库&quot;&gt;连接数据库&lt;/h2&gt;

&lt;p&gt;在使用前首先连接数据库（若没有则创建之）&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var mongoose = require('mongoose');

mongoose.connect('mongodb://localhost:27017/test'); 
//已连接
mongoose.connection.on('connected', function () {    
    console.log('已连接');  
});    
//连接错误
mongoose.connection.on('error',function (err) {    
    console.log('出错');  
});    
//断开连接
mongoose.connection.on('disconnected', function () {    
    console.log('断开连接');  
});    
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;其它事件可以自行查看：http://mongoosejs.com/docs/api.html#connection_Connection&lt;/p&gt;

&lt;h2 id=&quot;定义schema&quot;&gt;定义Schema&lt;/h2&gt;

&lt;p&gt;Schema是mongoose中需要事先定义的数据模式，类似于表结构，不过mongoDB中不叫表，叫collections。&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;模型可以看作mysql中的数据表，属性可以看作是字段，当然这个类比并不十分正确。&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;每个Schema对应当前连接的数据库的一个collection,若不存在则会自动创建。 &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;Schema不具备操作数据库的能力。 &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;下面我们来看下如何创建Schema&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var mongoose = require('mongoose');
Schema = mongoose.Schema;

var blogSchema = new Schema({
  title:  String,
  author: String,
  body:   String,
  comments: [{ body: String, date: Date }],
  date: { type: Date, default: Date.now },
  hidden: Boolean,
  meta: {
    votes: Number,
    favs:  Number
  }
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;type有下面这些，&lt;code class=&quot;highlighter-rouge&quot;&gt;String&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;Number&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;Boolean &lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;Array&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;Buffer&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;Date&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;ObjectId&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;Mixed&lt;/code&gt;类型&lt;/p&gt;

&lt;h2 id=&quot;生成model&quot;&gt;生成Model&lt;/h2&gt;

&lt;p&gt;模型Model是根据Schema编译出的构造器，或者称为类，通过Model可以实例化出文档对象document。 &lt;br /&gt;
下面根据Schema构建一个Model&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var Blog = mongoose.model('Blog', blogSchema);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;Model实例化之后为document。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var blogInstance = new Blog({
  ...
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;常用数据库操作&quot;&gt;常用数据库操作&lt;/h2&gt;

&lt;h3 id=&quot;新增&quot;&gt;新增&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;document.save()&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;model实例化后的document可用save新增文档&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//实例化model
var blogInstance = new Blog({
  ...
});
//调用save方法即插入一个新的document
user.save(function (err, res) {
    if (err) {
        console.log(&quot;Error:&quot; + err);
    }
    else {
        console.log(&quot;Res:&quot; + res);
    }
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;model.create()&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;使用save()方法，需要先实例化为文档，再使用save()方法保存文档。而create()方法，则直接在模型Model上操作，并且可以同时新增多个文档&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Blog.create({name:&quot;xiaowang&quot;},{name:&quot;xiaoli&quot;},function(err,doc1,doc2){
  console.log(doc1);
  console.log(doc2);
});  
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;h3 id=&quot;查询&quot;&gt;查询&lt;/h3&gt;

&lt;p&gt;查询文档有以下三种方法&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;find()
findById()
findOne()
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;find()&lt;/strong&gt;
第一个参数表示查询条件，第二个参数用于控制返回的字段，第三个参数用于配置查询参数，第四个参数是回调函数，回调函数的形式为function(err,docs){}&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Model.find(conditions, [projection], [options], [callback])
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;findById()&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Model.findById(id, [projection], [options], [callback])
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;findOne()&lt;/strong&gt;
该方法返回查找到的所有实例的第一个&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Model.findOne([conditions], [projection], [options], [callback])
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;h3 id=&quot;更新&quot;&gt;更新&lt;/h3&gt;
&lt;p&gt;更新文档有以下两种方法&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;update()
updateMany()
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;update()&lt;/strong&gt;
第一个参数conditions为查询条件，第二个参数doc为需要修改的数据，第三个参数options为控制选项，第四个参数是回调函数&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Model.update(conditions, doc, [options], [callback])
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;updateMany()&lt;/strong&gt;
updateMany()与update()方法唯一的区别就是默认更新多个文档，即使设置{multi:false}也无法只更新第一个文档&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Model.updateMany(conditions, doc, [options], [callback])
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;删除&quot;&gt;删除&lt;/h3&gt;
&lt;p&gt;更新文档有以下三种方法&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;remove()
findOneAndRemove()
findByIdAndRemove()
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;remove()&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;remove有两种形式，一种是文档的remove()方法，一种是Model的remove()方法。&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;下面介绍Model的remove()方法，该方法的第一个参数conditions为查询条件，第二个参数回调函数的形式如下function(err){}。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;model.remove(conditions, [callback])
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;下面介绍文档的remove()方法，该方法的参数回调函数的形式如下function(err,doc){}&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;document.remove([callback])
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;findOneAndRemove()&lt;/strong&gt;
model的remove()会删除符合条件的所有数据，如果只删除符合条件的第一条数据，则可以使用model的findOneAndRemove()方法&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Model.findOneAndRemove(conditions, [options], [callback])
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;findByIdAndRemove()&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Model.findByIdAndRemove(id, [options], [callback])
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;前后钩子&quot;&gt;前后钩子&lt;/h3&gt;
&lt;p&gt;前后钩子即pre()和post()方法，又称为中间件，是在执行某些操作时可以执行的函数。中间件在schema上指定，类似于静态方法或实例方法等&lt;/p&gt;

&lt;p&gt;可以在数据库执行下列操作时，设置前后钩子&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;init
validate
save
remove
count
find
findOne
findOneAndRemove
findOneAndUpdate
insertMany
update
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;pre()&lt;/strong&gt;
以find()方法为例，在执行find()方法之前，执行pre()方法&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var schema = new mongoose.Schema({ age:Number, name: String,x:Number,y:Number});  
schema.pre('find',function(next){
    console.log('我是pre方法1');
    next();
});
schema.pre('find',function(next){
    console.log('我是pre方法2');
    next();
});  
var temp = mongoose.model('temp', schema);
temp.find(function(err,docs){
    console.log(docs[0]);
})    
/*
我是pre方法1
我是pre方法2
{ _id: 5972ed35e6f98ec60e3dc886,name: 'huochai',age: 27,x: 1,y: 2 }
*/
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;查询后处理&quot;&gt;查询后处理&lt;/h3&gt;

&lt;p&gt;常用的查询后处理的方法如下所示&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sort     排序
skip     跳过
limit    限制
select   显示字段
exect    执行
count    计数
distinct 去重
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;例子&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//按照age从小到大排列
temp.find().sort(&quot;age&quot;).exec(function(err,docs){
    console.log(docs);
}); 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;文档验证&quot;&gt;文档验证&lt;/h3&gt;

&lt;p&gt;如果不进行文档验证，保存文档时，就可以不按照Schema设置的字段进行设置，分为以下几种情况&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;缺少字段的文档可以保存成功&lt;/li&gt;
  &lt;li&gt;包含未设置的字段的文档也可以保存成功，未设置的字段不被保存&lt;/li&gt;
  &lt;li&gt;包含字段类型与设置不同的字段的文档也可以保存成功，不同字段类型的字段被保存为设置的字段类型&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;而通过文档验证，就可以避免以上几种情况发生 &lt;br /&gt;
文档验证在SchemaType中定义，格式如下&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;name:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;{type:String,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;validator:value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;常用验证包括以下几种&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;required: 数据必须填写
default: 默认值
validate: 自定义匹配
min: 最小值(只适用于数字)
max: 最大值(只适用于数字)
match: 正则匹配(只适用于字符串)
enum:  枚举匹配(只适用于字符串)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;参考&quot;&gt;参考&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/xiaohuochai/p/7215067.html?utm_source=itdadao&amp;amp;utm_medium=referral&quot;&gt;Mongoose基础入门&lt;/a&gt; &lt;br /&gt;
&lt;a href=&quot;http://www.cnblogs.com/zhongweiv/p/mongoose.html&quot;&gt;Mongoose介绍和入门&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Fri, 20 Oct 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/mongodb/2017/10/20/mongoose.html</link>
        <guid isPermaLink="true">http://localhost:4000/mongodb/2017/10/20/mongoose.html</guid>
        
        <category>mongoose</category>
        
        
        <category>mongoDB</category>
        
      </item>
    
      <item>
        <title>HTTP与TCP/IP网络协议基础知识与重点</title>
        <description>&lt;h2 id=&quot;参考&quot;&gt;参考&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;http://www.jianshu.com/p/6e9e4156ece3&quot;&gt;一篇文章带你详解 HTTP 协议&lt;/a&gt; &lt;br /&gt;
&lt;a href=&quot;http://www.jianshu.com/p/9f3e879a4c9c&quot;&gt;一篇文章带你熟悉 TCP/IP 协议&lt;/a&gt; &lt;br /&gt;
&lt;a href=&quot;https://book.douban.com/subject/25863515/&quot;&gt;图解HTTP&lt;/a&gt; &lt;br /&gt;
&lt;a href=&quot;https://book.douban.com/subject/24737674/&quot;&gt;图解TCP/IP&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;http协议重点&quot;&gt;HTTP协议重点&lt;/h2&gt;
&lt;h3 id=&quot;1常用的http方法&quot;&gt;1.常用的HTTP方法&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;GET&lt;/strong&gt;： 用于请求访问已经被URI（统一资源标识符）识别的资源，可以通过URL传参给服务器。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;POST&lt;/strong&gt;：用于传输信息给服务器，主要功能与GET方法类似，但一般推荐使用POST方式。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;PUT&lt;/strong&gt;： 传输文件，报文主体中包含文件内容，保存到对应URI位置。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;HEAD&lt;/strong&gt;： 获得报文首部，与GET方法类似，只是不返回报文主体，一般用于验证URI是否有效。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;DELETE&lt;/strong&gt;：删除文件，与PUT方法相反，删除对应URI位置的文件。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;OPTIONS&lt;/strong&gt;：查询相应URI支持的HTTP方法。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;2get方法与post方法的区别&quot;&gt;2.GET方法与POST方法的区别&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;区别一：&lt;br /&gt;
get重点在从服务器上获取资源，post重点在向服务器发送数据；&lt;/li&gt;
  &lt;li&gt;区别二：&lt;br /&gt;
get传输数据是通过URL请求，以field（字段）= value的形式，置于URL后，并用”?”连接，多个请求数据间用”&amp;amp;”连接，如http://127.0.0.1/Test/login.action?name=admin&amp;amp;password=admin，这个过程用户是可见的；&lt;br /&gt;
post传输数据通过Http的post机制，将字段与对应值封存在请求实体中发送给服务器，这个过程对用户是不可见的；&lt;/li&gt;
  &lt;li&gt;区别三：&lt;br /&gt;
Get传输的数据量小，因为受URL长度限制，但效率较高；&lt;br /&gt;
Post可以传输大量数据，所以上传文件时只能用Post方式；&lt;/li&gt;
  &lt;li&gt;区别四：&lt;br /&gt;
get是不安全的，因为URL是可见的，可能会泄露私密信息，如密码等；&lt;br /&gt;
post较get安全性较高；&lt;/li&gt;
  &lt;li&gt;区别五：&lt;br /&gt;
get方式只能支持ASCII字符，向服务器传的中文字符可能会乱码。&lt;br /&gt;
post支持标准字符集，可以正确传递中文字符&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;3http请求报文与响应报文格式&quot;&gt;3.HTTP请求报文与响应报文格式&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;请求报文包含三部分：
    &lt;ol&gt;
      &lt;li&gt;请求行：包含请求方法、URI、HTTP版本信息&lt;/li&gt;
      &lt;li&gt;请求首部字段&lt;/li&gt;
      &lt;li&gt;请求内容实体&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;响应报文包含三部分：
    &lt;ol&gt;
      &lt;li&gt;状态行：包含HTTP版本、状态码、状态码的原因短语&lt;/li&gt;
      &lt;li&gt;响应首部字段&lt;/li&gt;
      &lt;li&gt;响应内容实体&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;4常见的http相应状态码&quot;&gt;4.常见的HTTP相应状态码&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;返回的状态&lt;br /&gt;
&lt;strong&gt;1xx&lt;/strong&gt;：指示信息–表示请求已接收，继续处理&lt;br /&gt;
&lt;strong&gt;2xx&lt;/strong&gt;：成功–表示请求已被成功接收、理解、接受&lt;br /&gt;
&lt;strong&gt;3xx&lt;/strong&gt;：重定向–要完成请求必须进行更进一步的操作&lt;br /&gt;
&lt;strong&gt;4xx&lt;/strong&gt;：客户端错误–请求有语法错误或请求无法实现&lt;br /&gt;
&lt;strong&gt;5xx&lt;/strong&gt;：服务器端错误–服务器未能实现合法的请求&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;常见状态码&lt;br /&gt;
&lt;strong&gt;200&lt;/strong&gt;：请求被正常处理&lt;br /&gt;
&lt;strong&gt;204&lt;/strong&gt;：请求被受理但没有资源可以返回&lt;br /&gt;
&lt;strong&gt;206&lt;/strong&gt;：客户端只是请求资源的一部分，服务器只对请求的部分资源执行GET方法，相应报文中通过Content-Range指定范围的资源。&lt;br /&gt;
&lt;strong&gt;301&lt;/strong&gt;：永久性重定向&lt;br /&gt;
&lt;strong&gt;302&lt;/strong&gt;：临时重定向&lt;br /&gt;
&lt;strong&gt;303&lt;/strong&gt;：与302状态码有相似功能，只是它希望客户端在请求一个URI的时候，能通过GET方法重定向到另一个URI上&lt;br /&gt;
&lt;strong&gt;304&lt;/strong&gt;：发送附带条件的请求时，条件不满足时返回，与重定向无关&lt;br /&gt;
&lt;strong&gt;307&lt;/strong&gt;：临时重定向，与302类似，只是强制要求使用POST方法&lt;br /&gt;
&lt;strong&gt;400&lt;/strong&gt;：请求报文语法有误，服务器无法识别&lt;br /&gt;
&lt;strong&gt;401&lt;/strong&gt;：请求需要认证&lt;br /&gt;
&lt;strong&gt;403&lt;/strong&gt;：请求的对应资源禁止被访问&lt;br /&gt;
&lt;strong&gt;404&lt;/strong&gt;：服务器无法找到对应资源&lt;br /&gt;
&lt;strong&gt;500&lt;/strong&gt;：服务器内部错误&lt;br /&gt;
&lt;strong&gt;503&lt;/strong&gt;：服务器正忙&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;tcpip协议重点&quot;&gt;TCP/IP协议重点&lt;/h2&gt;

&lt;h3 id=&quot;1计算机网络体系结构分层&quot;&gt;1.计算机网络体系结构分层&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;/img/postsImg/http/pic1.png&quot; alt=&quot;分层模型&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;2数据处理流程&quot;&gt;2.数据处理流程&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/img/postsImg/http/pic2.png&quot; alt=&quot;数据处理流程&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;3tcp连接建立释放时的握手过程&quot;&gt;3.TCP连接建立、释放时的握手过程　　&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;三次握手&lt;/strong&gt; &lt;br /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;TCP 提供面向有连接的通信传输。面向有连接是指在数据通信开始之前先做好两端之间的准备工作。&lt;/li&gt;
  &lt;li&gt;所谓三次握手是指建立一个 TCP 连接时需要客户端和服务器端总共发送三个包以确认连接的建立。在socket编程中，这一过程由客户端执行connect来触发。
&lt;br /&gt;
下面来看看三次握手的流程图：
&lt;img src=&quot;/img/postsImg/http/pic3.png&quot; alt=&quot;流程图&quot; /&gt;&lt;/li&gt;
  &lt;li&gt;第一次握手：客户端将标志位SYN置为1，随机产生一个值seq=J，并将该数据包发送给服务器端，客户端进入SYN_SENT状态，等待服务器端确认。&lt;/li&gt;
  &lt;li&gt;第二次握手：服务器端收到数据包后由标志位SYN=1知道客户端请求建立连接，服务器端将标志位SYN和ACK都置为1，ack=J+1，随机产生一个值seq=K，并将该数据包发送给客户端以确认连接请求，服务器端进入SYN_RCVD状态。&lt;/li&gt;
  &lt;li&gt;第三次握手：客户端收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给服务器端，服务器端检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，客户端和服务器端进入ESTABLISHED状态，完成三次握手，随后客户端与服务器端之间可以开始传输数据了。
&lt;br /&gt;
&lt;strong&gt;四次挥手&lt;/strong&gt; &lt;br /&gt;&lt;/li&gt;
  &lt;li&gt;四次挥手即终止TCP连接，就是指断开一个TCP连接时，需要客户端和服务端总共发送4个包以确认连接的断开。在socket编程中，这一过程由客户端或服务端任一方执行close来触发。&lt;/li&gt;
  &lt;li&gt;由于TCP连接是全双工的，因此，每个方向都必须要单独进行关闭，这一原则是当一方完成数据发送任务后，发送一个FIN来终止这一方向的连接，收到一个FIN只是意味着这一方向上没有数据流动了，即不会再收到数据了，但是在这个TCP连接上仍然能够发送数据，直到这一方向也发送了FIN。首先进行关闭的一方将执行主动关闭，而另一方则执行被动关闭。
&lt;br /&gt;
下面来看看四次挥手的流程图：
&lt;img src=&quot;/img/postsImg/http/pic4.png&quot; alt=&quot;流程图&quot; /&gt;&lt;/li&gt;
  &lt;li&gt;中断连接端可以是客户端，也可以是服务器端。&lt;/li&gt;
  &lt;li&gt;第一次挥手：客户端发送一个FIN=M，用来关闭客户端到服务器端的数据传送，客户端进入FIN_WAIT_1状态。意思是说”我客户端没有数据要发给你了”，但是如果你服务器端还有数据没有发送完成，则不必急着关闭连接，可以继续发送数据。&lt;/li&gt;
  &lt;li&gt;第二次挥手：服务器端收到FIN后，先发送ack=M+1，告诉客户端，你的请求我收到了，但是我还没准备好，请继续你等我的消息。这个时候客户端就进入FIN_WAIT_2 状态，继续等待服务器端的FIN报文。&lt;/li&gt;
  &lt;li&gt;第三次挥手：当服务器端确定数据已发送完成，则向客户端发送FIN=N报文，告诉客户端，好了，我这边数据发完了，准备好关闭连接了。服务器端进入LAST_ACK状态。&lt;/li&gt;
  &lt;li&gt;第四次挥手：客户端收到FIN=N报文后，就知道可以关闭连接了，但是他还是不相信网络，怕服务器端不知道要关闭，所以发送ack=N+1后进入TIME_WAIT状态，如果Server端没有收到ACK则可以重传。服务器端收到ACK后，就知道可以断开连接了。客户端等待了2MSL后依然没有收到回复，则证明服务器端已正常关闭，那好，我客户端也可以关闭连接了。最终完成了四次握手。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;

&lt;p&gt;以上的都是些网络协议方面的老生常谈的基础知识，其中内容十分不完整和全面。主要是要有一些网络方面的基础概念，遇到问题的时候懂得要到哪里去查，一些细的方面的知识可以等到实际应用中去体会。&lt;/p&gt;

</description>
        <pubDate>Wed, 11 Oct 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/net/2017/10/11/net.html</link>
        <guid isPermaLink="true">http://localhost:4000/net/2017/10/11/net.html</guid>
        
        <category>HTTP</category>
        
        <category>TCP/IP</category>
        
        
        <category>net</category>
        
      </item>
    
      <item>
        <title>[译]一个100行内的现代js路由</title>
        <description>&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;原文:http://krasimirtsonev.com/blog/article/A-modern-JavaScript-router-in-100-lines-history-api-pushState-hash-url
作者:Krasimir
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;(这个js路由现在被放项目&lt;a href=&quot;https://github.com/krasimir/navigo&quot;&gt;Navigo&lt;/a&gt;中。这里还有一篇你可能会感兴趣的文章&lt;a href=&quot;http://krasimirtsonev.com/blog/article/deep-dive-into-client-side-routing-navigo-pushstate-hash&quot;&gt;Deep dive into client-side routing&lt;/a&gt;)&lt;/p&gt;

&lt;p&gt;现今到处都是流行的单页面应用（SPA）。这样的应用需要一个坚实的路由机制。像&lt;a href=&quot;https://emberjs.com/&quot;&gt;Emberjs&lt;/a&gt;这样的框架确实是在建立在一个路由类上的。我不确定这是不是我喜欢的概念，但我确定的是&lt;a href=&quot;http://absurdjs.com/&quot;&gt;AbsurdJS&lt;/a&gt;需要一个内置的路由。并且这个路由在所有东西齐全的前提下，应该小巧、简单。那就让我们来看看这样一个模块是怎么样的。&lt;/p&gt;

&lt;h2 id=&quot;要求&quot;&gt;要求&lt;/h2&gt;

&lt;p&gt;这个路由应该符合下面几点&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;应该小于100行&lt;/li&gt;
  &lt;li&gt;支持像&lt;em&gt;http://site.com#products/list&lt;/em&gt;这样的hash类型的url&lt;/li&gt;
  &lt;li&gt;也能使用History API&lt;/li&gt;
  &lt;li&gt;提供易用的API&lt;/li&gt;
  &lt;li&gt;不会自动的运行&lt;/li&gt;
  &lt;li&gt;可选择监听改变&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;单例模式&quot;&gt;单例模式&lt;/h2&gt;

&lt;p&gt;我决定把路由做成只有一个实例。这也许是个坏决定，因为我就有个项目需要多个路由，但要知道这个不是常有的应用。如果我们使用单例模式，我们就不需要把路由从一个对象传到另一个对象并且我们也不需要创建它。我们只需要一个实例，这样我们就可以自动的创建它。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var Router = {
    routes: [],
    mode: null,
    root: '/'
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;这里有三个我们需要的属性。&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;routes-这个保存着当前已注册的路由&lt;/li&gt;
  &lt;li&gt;mode-根据我们使用的是history还是hash显示’hash’或者’history’&lt;/li&gt;
  &lt;li&gt;root-应用的根URL路径，只有当我们使用pushState的时候我们才需要&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;配置&quot;&gt;配置&lt;/h2&gt;

&lt;p&gt;我们需要一个方法来初始化路由。我们只需要传两个东西，但是最好在一个函数内做这些。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var Router = {
    routes: [],
    mode: null,
    root: '/',
    config: function(options) {
        this.mode = options &amp;amp;&amp;amp; options.mode &amp;amp;&amp;amp; options.mode == 'history' 
                    &amp;amp;&amp;amp; !!(history.pushState) ? 'history' : 'hash';
        this.root = options &amp;amp;&amp;amp; options.root ? '/' + this.clearSlashes(options.root) + '/' : '/';
        return this;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;只有当我们想要使用history模式并且支持&lt;em&gt;pushState&lt;/em&gt;的时候，mode才会等于’history’。否则我们将使用hash。root默认设置为单斜线’/’。&lt;/p&gt;

&lt;h2 id=&quot;获得当前的url&quot;&gt;获得当前的URL&lt;/h2&gt;

&lt;p&gt;这是我们的路由的重要部分，因为这将会告诉我们现在在什么地方。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;getFragment: function() {
    var fragment = '';
    if(this.mode === 'history') {
        fragment = this.clearSlashes(decodeURI(location.pathname + location.search));
        fragment = fragment.replace(/\?(.*)$/, '');
        fragment = this.root != '/' ? fragment.replace(this.root, '') : fragment;
    } else {
        var match = window.location.href.match(/#(.*)$/);
        fragment = match ? match[1] : '';
    }
    return this.clearSlashes(fragment);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在两个例子中我们都是用了全局的&lt;em&gt;window.location&lt;/em&gt;对象。在’history’模式版本中我们需要去掉URL的根部分。我们也需要去掉所有的GET请求参数，我们用如下的正则表达式搞定-&lt;code class=&quot;highlighter-rouge&quot;&gt;(/\?(.*)$/)&lt;/code&gt;。获取hash的值则更加简单点。注意&lt;em&gt;clearSlashes&lt;/em&gt;函数的作用。它的用处是去除字符串开头和结尾的斜杠。这是有必要的，因为我们不能强迫开发者使用特定格式的URL。无论他传什么都会转成同样的值。&lt;/p&gt;

&lt;h2 id=&quot;添加和修改路由&quot;&gt;添加和修改路由&lt;/h2&gt;

&lt;p&gt;当我在制作&lt;a href=&quot;http://absurdjs.com/&quot;&gt;AbsurdJS&lt;/a&gt;的时候，我总是尝试尽可能多的给开发者控制权。几乎所有的路由插件在执行路由的时候是用字符串路由。然而我更喜欢传一个正则表达式。这更加的灵活，因为有的时候我们也许会做很奇怪的匹配。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;add: function(re, handler) {
    if(typeof re == 'function') {
        handler = re;
        re = '';
    }
    this.routes.push({ re: re, handler: handler});
    return this;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;这个将&lt;em&gt;routes&lt;/em&gt;数组进行填充。如果只有一个函数传进来，那么这个函数就会被作为handler，而默认的路由就是一个空字符串。注意这里大部分的函数return this。这可以让我们链式调用方法。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;remove: function(param) {
    for(var i=0, r; i&amp;lt;this.routes.length, r = this.routes[i]; i++) {
        if(r.handler === param || r.re.toString() === param.toString()) {
            this.routes.splice(i, 1); 
            return this;
        }
    }
    return this;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;只有我们传一个正则表达式或者handler传给&lt;em&gt;add&lt;/em&gt;方法的时候，路由的删除才会调用。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;flush: function() {
    this.routes = [];
    this.mode = null;
    this.root = '/';
    return this;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;有的时候我们需要重新初始化类。那么这时候你就可以用上面的&lt;em&gt;flush&lt;/em&gt;方法。&lt;/p&gt;

&lt;h2 id=&quot;登记&quot;&gt;登记&lt;/h2&gt;

&lt;p&gt;好，现在我们已经有了增加和删除URL的API。我们也可以得到当前的地址了。下一步我们要比较已注册的入口。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;check: function(f) {
    var fragment = f || this.getFragment();
    for(var i=0; i&amp;lt;this.routes.length; i++) {
        var match = fragment.match(this.routes[i].re);
        if(match) {
            match.shift();
            this.routes[i].handler.apply({}, match);
            return this;
        }           
    }
    return this;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;我们通过传入函数作为参数或者调用&lt;em&gt;getFragment&lt;/em&gt;方法来获得&lt;em&gt;fragment&lt;/em&gt;。接下来我们执行一个单纯的循环来遍历routes来查看匹配。只有当正则表达式没有匹配到的时候，变量&lt;em&gt;match&lt;/em&gt;的值是null。否则&lt;em&gt;match&lt;/em&gt;的值会像下面这样&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[&quot;products/12/edit/22&quot;, &quot;12&quot;, &quot;22&quot;, index: 1, input: &quot;/products/12/edit/22&quot;]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;这是一个包含了匹配到的数组和所有可记录的子串的类数组。这意味着如果我们&lt;em&gt;shift&lt;/em&gt;第一个我们会获得URL动态部分的数组。举例：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Router
.add(/about/, function() {
    console.log('about');
})
.add(/products\/(.*)\/edit\/(.*)/, function() {
    console.log('products', arguments);
})
.add(function() {
    console.log('default');
})
.check('/products/12/edit/22');
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;这段脚本输出&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;products [&quot;12&quot;, &quot;22&quot;]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;到此为止我们处理了动态URL。&lt;/p&gt;

&lt;h2 id=&quot;监听变化&quot;&gt;监听变化&lt;/h2&gt;

&lt;p&gt;当然我们不能总是调用&lt;em&gt;check&lt;/em&gt;方法。我们需要当地址栏改变的时候，我们能收到通知。我所说的改变甚至意味着点击浏览器上的后退按钮。如果你用过History API的话你就会知道有一个&lt;em&gt;popstate&lt;/em&gt;事件。当URL改变的时候就会触发这个事件。然而我发现在一些浏览器中，当页面加载完的时候会分发这个事件。这个情况加上其他的一些问题让我转向了其他的解决方案。因为我希望甚至在模式被设置为hash也能进行监听，我决定采用setinterval。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;listen: function() {
    var self = this;
    var current = self.getFragment();
    var fn = function() {
        if(current !== self.getFragment()) {
            current = self.getFragment();
            self.check(current);
        }
    }
    clearInterval(this.interval);
    this.interval = setInterval(fn, 50);
    return this;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;我们需要把最近的URL存下来这样我们才能用于对比下一个。&lt;/p&gt;

&lt;h2 id=&quot;改变url&quot;&gt;改变URL&lt;/h2&gt;
&lt;p&gt;最后我们需要一个函数能改变当前的地址并触发路由handler&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;navigate: function(path) {
    path = path ? path : '';
    if(this.mode === 'history') {
        history.pushState(null, null, this.root + this.clearSlashes(path));
    } else {        
        window.location.href = window.location.href.replace(/#(.*)$/, '') + '#' + path;
    }
    return this;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;同样的，我们根据不同的模式做不同的事。如果History API可用，我们使用&lt;em&gt;pushState&lt;/em&gt;。否则我们就采用window.location。&lt;/p&gt;

&lt;h2 id=&quot;最终源码&quot;&gt;最终源码&lt;/h2&gt;

&lt;p&gt;以下是最终源码加一点例子&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var Router = {
    routes: [],
    mode: null,
    root: '/',
    config: function(options) {
        this.mode = options &amp;amp;&amp;amp; options.mode &amp;amp;&amp;amp; options.mode == 'history' 
                    &amp;amp;&amp;amp; !!(history.pushState) ? 'history' : 'hash';
        this.root = options &amp;amp;&amp;amp; options.root ? '/' + this.clearSlashes(options.root) + '/' : '/';
        return this;
    },
    getFragment: function() {
        var fragment = '';
        if(this.mode === 'history') {
            fragment = this.clearSlashes(decodeURI(location.pathname + location.search));
            fragment = fragment.replace(/\?(.*)$/, '');
            fragment = this.root != '/' ? fragment.replace(this.root, '') : fragment;
        } else {
            var match = window.location.href.match(/#(.*)$/);
            fragment = match ? match[1] : '';
        }
        return this.clearSlashes(fragment);
    },
    clearSlashes: function(path) {
        return path.toString().replace(/\/$/, '').replace(/^\//, '');
    },
    add: function(re, handler) {
        if(typeof re == 'function') {
            handler = re;
            re = '';
        }
        this.routes.push({ re: re, handler: handler});
        return this;
    },
    remove: function(param) {
        for(var i=0, r; i&amp;lt;this.routes.length, r = this.routes[i]; i++) {
            if(r.handler === param || r.re.toString() === param.toString()) {
                this.routes.splice(i, 1); 
                return this;
            }
        }
        return this;
    },
    flush: function() {
        this.routes = [];
        this.mode = null;
        this.root = '/';
        return this;
    },
    check: function(f) {
        var fragment = f || this.getFragment();
        for(var i=0; i&amp;lt;this.routes.length; i++) {
            var match = fragment.match(this.routes[i].re);
            if(match) {
                match.shift();
                this.routes[i].handler.apply({}, match);
                return this;
            }           
        }
        return this;
    },
    listen: function() {
        var self = this;
        var current = self.getFragment();
        var fn = function() {
            if(current !== self.getFragment()) {
                current = self.getFragment();
                self.check(current);
            }
        }
        clearInterval(this.interval);
        this.interval = setInterval(fn, 50);
        return this;
    },
    navigate: function(path) {
        path = path ? path : '';
        if(this.mode === 'history') {
            history.pushState(null, null, this.root + this.clearSlashes(path));
        } else {
            window.location.href = window.location.href.replace(/#(.*)$/, '') + '#' + path;
        }
        return this;
    }
}

// configuration
Router.config({ mode: 'history'});

// returning the user to the initial state
Router.navigate();

// adding routes
Router
.add(/about/, function() {
    console.log('about');
})
.add(/products\/(.*)\/edit\/(.*)/, function() {
    console.log('products', arguments);
})
.add(function() {
    console.log('default');
})
.check('/products/12/edit/22').listen();

// forwarding
Router.navigate('/about');
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;

&lt;p&gt;这个路由大概90行。支持hash类型的URL和新的history API。如果你不想仅仅想使用路由这个功能而使用整个框架，这个就对你是有帮助的。&lt;/p&gt;

&lt;p&gt;这个类是&lt;a href=&quot;http://absurdjs.com/&quot;&gt;AbsurdJS&lt;/a&gt;的一部分。在&lt;a href=&quot;http://absurdjs.com/pages/api/build-in-components/#router&quot;&gt;这里&lt;/a&gt;可以查看文档。&lt;/p&gt;
</description>
        <pubDate>Tue, 10 Oct 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/js/2017/10/10/routes-in-100-line.html</link>
        <guid isPermaLink="true">http://localhost:4000/js/2017/10/10/routes-in-100-line.html</guid>
        
        <category>routes</category>
        
        <category>路由</category>
        
        
        <category>js</category>
        
      </item>
    
      <item>
        <title>入门正则表达式</title>
        <description>&lt;h2 id=&quot;资料&quot;&gt;资料&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;http://deerchao.net/tutorials/regex/regex.htm&quot;&gt;正则表达式30分钟入门教程&lt;/a&gt;
&lt;a href=&quot;https://juejin.im/post/582455e467f3560058c6641e&quot;&gt;《JavaScript 闯关记》之正则表达式&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;正则表达式是什么&quot;&gt;正则表达式是什么&lt;/h2&gt;

&lt;p&gt;在编写处理字符串的程序或网页时，经常会有查找符合某些复杂规则的字符串的需要。正则表达式就是用于描述这些规则的工具。换句话说，正则表达式就是记录文本规则的代码。&lt;/p&gt;

&lt;h2 id=&quot;为什么要用正则表达式&quot;&gt;为什么要用正则表达式&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;密码、账号等验证。&lt;/li&gt;
  &lt;li&gt;看源码需要，写框架，后端编程，路由都离不开正则&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;元字符&quot;&gt;元字符&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;http://www.runoob.com/regexp/regexp-metachar.html&quot;&gt;常用的正则表达式元字符&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;例子加深理解&quot;&gt;例子加深理解&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;例子一 &lt;br /&gt;
    &lt;ul&gt;
      &lt;li&gt;正则表达式:&lt;code class=&quot;highlighter-rouge&quot;&gt;\bhi\b.*\bLucy\b&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;含义:先是一个单词hi,然后是任意个任意字符(但不能是换行)，最后是Lucy这个单词&lt;/li&gt;
      &lt;li&gt;知识点:&lt;/li&gt;
    &lt;/ul&gt;
    &lt;ol&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;\b&lt;/code&gt;:代表着&lt;em&gt;单词的开头或结尾，也就是单词的分界处&lt;/em&gt;&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;.&lt;/code&gt;:匹配&lt;em&gt;除了换行符以外的任意字符&lt;/em&gt;&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;*&lt;/code&gt;:它指定&lt;em&gt;前边的内容可以连续重复使用任意次以使整个表达式得到匹配&lt;/em&gt;&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;例子二
    &lt;ul&gt;
      &lt;li&gt;正则表达式:&lt;code class=&quot;highlighter-rouge&quot;&gt;0\d\d-\d\d\d\d\d\d\d\d&lt;/code&gt; 或 &lt;code class=&quot;highlighter-rouge&quot;&gt;0\d{2}-\d{8}&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;含义:以0开头，然后是两个数字，然后是一个连字号“-”，最后是8个数字&lt;/li&gt;
      &lt;li&gt;知识点:&lt;/li&gt;
    &lt;/ul&gt;
    &lt;ol&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;\d&lt;/code&gt;:匹配&lt;em&gt;一位数字&lt;/em&gt;&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;:匹配&lt;em&gt;必须连续重复匹配2次&lt;/em&gt;&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;例子三
    &lt;ul&gt;
      &lt;li&gt;正则表达式:&lt;code class=&quot;highlighter-rouge&quot;&gt;\ba\w*\b&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;含义:a开头的单词——先是某个单词开始处(\b)，然后是字母a,然后是任意数量的字母或数字(\w*)，最后是单词结束处(\b)&lt;/li&gt;
      &lt;li&gt;知识点:&lt;/li&gt;
    &lt;/ul&gt;
    &lt;ol&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;\w&lt;/code&gt;:匹配&lt;em&gt;字母或数字或下划线或汉字等&lt;/em&gt;&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;\s&lt;/code&gt;:匹配&lt;em&gt;任意的空白符，包括空格，制表符(Tab)，换行符，中文全角空格等&lt;/em&gt;（虽然这里没有）&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;还有一些元字符&quot;&gt;还有一些元字符&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;^&lt;/code&gt;:匹配&lt;em&gt;匹配字符串的开始&lt;/em&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;$&lt;/code&gt;:匹配&lt;em&gt;匹配字符串的结束&lt;/em&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;n,m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;:重复的次数不能少于n次，不能多于m次&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;\&lt;/code&gt;:标记为一个元字符、或一个原义字符、或一个 向后引用、或一个八进制转义符&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;重复：&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th&gt;代码/语法&lt;/th&gt;
          &lt;th&gt;说明&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td&gt;*&lt;/td&gt;
          &lt;td&gt;重复零次或更多次&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;+&lt;/td&gt;
          &lt;td&gt;重复一次或更多次&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;?&lt;/td&gt;
          &lt;td&gt;重复零次或一次&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;{n}&lt;/td&gt;
          &lt;td&gt;重复n次&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;{n,}&lt;/td&gt;
          &lt;td&gt;重复n次或更多次&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;{n,m}&lt;/td&gt;
          &lt;td&gt;重复n到m次&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;字符类&lt;/p&gt;

    &lt;p&gt;匹配没有预定义元字符的字符集合 : 只需要在方括号里列出它们就行了 &lt;br /&gt;
 如：&lt;code class=&quot;highlighter-rouge&quot;&gt;[aeiou]&lt;/code&gt;就匹配任何一个英文元音字母&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;一些稍微高级的话题&quot;&gt;一些稍微高级的话题&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;分枝条件：&lt;code class=&quot;highlighter-rouge&quot;&gt;|&lt;/code&gt;类似于编程中的&lt;em&gt;或&lt;/em&gt;，指的是有几种规则，如果满足其中任意一种规则都应该当成匹配&lt;/li&gt;
  &lt;li&gt;分组：用小括号来指定&lt;em&gt;子表达式&lt;/em&gt;&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;反义：&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th&gt;代码/语法&lt;/th&gt;
          &lt;th&gt;说明&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td&gt;\W&lt;/td&gt;
          &lt;td&gt;匹配任意不是字母，数字，下划线，汉字的字符&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;\S&lt;/td&gt;
          &lt;td&gt;匹配任意不是空白符的字符&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;\D&lt;/td&gt;
          &lt;td&gt;匹配任意非数字的字符&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;\B&lt;/td&gt;
          &lt;td&gt;匹配不是单词开头或结束的位置&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;[^x]&lt;/td&gt;
          &lt;td&gt;匹配除了x以外的任意字符&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;[^aeiou]&lt;/td&gt;
          &lt;td&gt;匹配除了aeiou这几个字母以外的任意字符&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/li&gt;
  &lt;li&gt;后向引用：使用小括号指定一个子表达式后，匹配这个子表达式的文本(也就是此分组捕获的内容)可以在表达式或其它程序中作进一步的处理。默认情况下，每个分组会自动拥有一个组号。&lt;br /&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;后向引用&lt;/code&gt;用于重复搜索前面某个分组匹配的文本。例如，&lt;code class=&quot;highlighter-rouge&quot;&gt;\1&lt;/code&gt;代表分组1匹配的文本。&lt;/li&gt;
  &lt;li&gt;零宽断言：查找在某些内容(但并不包括这些内容)之前或之后的东西。&lt;br /&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;(?=exp)&lt;/code&gt;也叫&lt;code class=&quot;highlighter-rouge&quot;&gt;零宽度正预测先行断言&lt;/code&gt;，它断言自身出现的位置的后面能匹配表达式exp。比如&lt;code class=&quot;highlighter-rouge&quot;&gt;\b\w+(?=ing\b)&lt;/code&gt;，匹配以ing结尾的单词的前面部分(除了ing以外的部分)，如查找I’m singing while you’re dancing.时，它会匹配&lt;code class=&quot;highlighter-rouge&quot;&gt;sing&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;danc&lt;/code&gt;。&lt;/li&gt;
  &lt;li&gt;负向零宽断言：确保某个字符没有出现，但并不想去匹配它&lt;/li&gt;
  &lt;li&gt;贪婪与懒惰：当正则表达式中包含能接受重复的限定符时，通常的行为是（在使整个表达式能得到匹配的前提下）&lt;code class=&quot;highlighter-rouge&quot;&gt;匹配尽可能多的字符&lt;/code&gt;。有时，我们更需要懒惰匹配，也就是匹配尽可能少的字符。前面给出的限定符都可以被转化为懒惰匹配模式，只要在它后面加上一个问号&lt;code class=&quot;highlighter-rouge&quot;&gt;?&lt;/code&gt;。&lt;/li&gt;
  &lt;li&gt;平衡组/递归匹配&lt;/li&gt;
&lt;/ol&gt;

</description>
        <pubDate>Thu, 10 Aug 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/%E5%9F%BA%E7%A1%80/2017/08/10/regex.html</link>
        <guid isPermaLink="true">http://localhost:4000/%E5%9F%BA%E7%A1%80/2017/08/10/regex.html</guid>
        
        <category>regex</category>
        
        
        <category>基础</category>
        
      </item>
    
  </channel>
</rss>
