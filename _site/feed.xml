<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>侯星伊的个人博客</title>
    <description>A Simple Jekyll Blog Theme. # this means to ignore newlines until &quot;baseurl:&quot;
</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Thu, 09 Nov 2017 17:11:08 +0800</pubDate>
    <lastBuildDate>Thu, 09 Nov 2017 17:11:08 +0800</lastBuildDate>
    <generator>Jekyll v3.4.3</generator>
    
      <item>
        <title>入门正则表达式</title>
        <description>&lt;h2 id=&quot;资料&quot;&gt;资料&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;http://deerchao.net/tutorials/regex/regex.htm&quot;&gt;正则表达式30分钟入门教程&lt;/a&gt;
&lt;a href=&quot;https://juejin.im/post/582455e467f3560058c6641e&quot;&gt;《JavaScript 闯关记》之正则表达式&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;正则表达式是什么&quot;&gt;正则表达式是什么&lt;/h2&gt;

&lt;p&gt;在编写处理字符串的程序或网页时，经常会有查找符合某些复杂规则的字符串的需要。正则表达式就是用于描述这些规则的工具。换句话说，正则表达式就是记录文本规则的代码。&lt;/p&gt;

&lt;h2 id=&quot;为什么要用正则表达式&quot;&gt;为什么要用正则表达式&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;密码、账号等验证。&lt;/li&gt;
  &lt;li&gt;看源码需要，写框架，后端编程，路由都离不开正则&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;元字符&quot;&gt;元字符&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;http://www.runoob.com/regexp/regexp-metachar.html&quot;&gt;常用的正则表达式元字符&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;例子加深理解&quot;&gt;例子加深理解&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;例子一 &lt;br /&gt;
    &lt;ul&gt;
      &lt;li&gt;正则表达式:&lt;code class=&quot;highlighter-rouge&quot;&gt;\bhi\b.*\bLucy\b&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;含义:先是一个单词hi,然后是任意个任意字符(但不能是换行)，最后是Lucy这个单词&lt;/li&gt;
      &lt;li&gt;知识点:&lt;/li&gt;
    &lt;/ul&gt;
    &lt;ol&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;\b&lt;/code&gt;:代表着&lt;em&gt;单词的开头或结尾，也就是单词的分界处&lt;/em&gt;&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;.&lt;/code&gt;:匹配&lt;em&gt;除了换行符以外的任意字符&lt;/em&gt;&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;*&lt;/code&gt;:它指定&lt;em&gt;前边的内容可以连续重复使用任意次以使整个表达式得到匹配&lt;/em&gt;&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;例子二
    &lt;ul&gt;
      &lt;li&gt;正则表达式:&lt;code class=&quot;highlighter-rouge&quot;&gt;0\d\d-\d\d\d\d\d\d\d\d&lt;/code&gt; 或 &lt;code class=&quot;highlighter-rouge&quot;&gt;0\d{2}-\d{8}&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;含义:以0开头，然后是两个数字，然后是一个连字号“-”，最后是8个数字&lt;/li&gt;
      &lt;li&gt;知识点:&lt;/li&gt;
    &lt;/ul&gt;
    &lt;ol&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;\d&lt;/code&gt;:匹配&lt;em&gt;一位数字&lt;/em&gt;&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;:匹配&lt;em&gt;必须连续重复匹配2次&lt;/em&gt;&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;例子三
    &lt;ul&gt;
      &lt;li&gt;正则表达式:&lt;code class=&quot;highlighter-rouge&quot;&gt;\ba\w*\b&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;含义:a开头的单词——先是某个单词开始处(\b)，然后是字母a,然后是任意数量的字母或数字(\w*)，最后是单词结束处(\b)&lt;/li&gt;
      &lt;li&gt;知识点:&lt;/li&gt;
    &lt;/ul&gt;
    &lt;ol&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;\w&lt;/code&gt;:匹配&lt;em&gt;字母或数字或下划线或汉字等&lt;/em&gt;&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;\s&lt;/code&gt;:匹配&lt;em&gt;任意的空白符，包括空格，制表符(Tab)，换行符，中文全角空格等&lt;/em&gt;（虽然这里没有）&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;还有一些元字符&quot;&gt;还有一些元字符&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;^&lt;/code&gt;:匹配&lt;em&gt;匹配字符串的开始&lt;/em&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;$&lt;/code&gt;:匹配&lt;em&gt;匹配字符串的结束&lt;/em&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;n,m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;:重复的次数不能少于n次，不能多于m次&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;\&lt;/code&gt;:标记为一个元字符、或一个原义字符、或一个 向后引用、或一个八进制转义符&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;重复：&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th&gt;代码/语法&lt;/th&gt;
          &lt;th&gt;说明&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td&gt;*&lt;/td&gt;
          &lt;td&gt;重复零次或更多次&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;+&lt;/td&gt;
          &lt;td&gt;重复一次或更多次&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;?&lt;/td&gt;
          &lt;td&gt;重复零次或一次&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;{n}&lt;/td&gt;
          &lt;td&gt;重复n次&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;{n,}&lt;/td&gt;
          &lt;td&gt;重复n次或更多次&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;{n,m}&lt;/td&gt;
          &lt;td&gt;重复n到m次&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;字符类&lt;/p&gt;

    &lt;p&gt;匹配没有预定义元字符的字符集合 : 只需要在方括号里列出它们就行了 &lt;br /&gt;
 如：&lt;code class=&quot;highlighter-rouge&quot;&gt;[aeiou]&lt;/code&gt;就匹配任何一个英文元音字母&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;一些稍微高级的话题&quot;&gt;一些稍微高级的话题&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;分枝条件：&lt;code class=&quot;highlighter-rouge&quot;&gt;|&lt;/code&gt;类似于编程中的&lt;em&gt;或&lt;/em&gt;，指的是有几种规则，如果满足其中任意一种规则都应该当成匹配&lt;/li&gt;
  &lt;li&gt;分组：用小括号来指定&lt;em&gt;子表达式&lt;/em&gt;&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;反义：&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th&gt;代码/语法&lt;/th&gt;
          &lt;th&gt;说明&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td&gt;\W&lt;/td&gt;
          &lt;td&gt;匹配任意不是字母，数字，下划线，汉字的字符&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;\S&lt;/td&gt;
          &lt;td&gt;匹配任意不是空白符的字符&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;\D&lt;/td&gt;
          &lt;td&gt;匹配任意非数字的字符&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;\B&lt;/td&gt;
          &lt;td&gt;匹配不是单词开头或结束的位置&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;[^x]&lt;/td&gt;
          &lt;td&gt;匹配除了x以外的任意字符&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;[^aeiou]&lt;/td&gt;
          &lt;td&gt;匹配除了aeiou这几个字母以外的任意字符&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/li&gt;
  &lt;li&gt;后向引用：使用小括号指定一个子表达式后，匹配这个子表达式的文本(也就是此分组捕获的内容)可以在表达式或其它程序中作进一步的处理。默认情况下，每个分组会自动拥有一个组号。&lt;br /&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;后向引用&lt;/code&gt;用于重复搜索前面某个分组匹配的文本。例如，&lt;code class=&quot;highlighter-rouge&quot;&gt;\1&lt;/code&gt;代表分组1匹配的文本。&lt;/li&gt;
  &lt;li&gt;零宽断言：查找在某些内容(但并不包括这些内容)之前或之后的东西。&lt;br /&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;(?=exp)&lt;/code&gt;也叫&lt;code class=&quot;highlighter-rouge&quot;&gt;零宽度正预测先行断言&lt;/code&gt;，它断言自身出现的位置的后面能匹配表达式exp。比如&lt;code class=&quot;highlighter-rouge&quot;&gt;\b\w+(?=ing\b)&lt;/code&gt;，匹配以ing结尾的单词的前面部分(除了ing以外的部分)，如查找I’m singing while you’re dancing.时，它会匹配&lt;code class=&quot;highlighter-rouge&quot;&gt;sing&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;danc&lt;/code&gt;。&lt;/li&gt;
  &lt;li&gt;负向零宽断言：确保某个字符没有出现，但并不想去匹配它&lt;/li&gt;
  &lt;li&gt;贪婪与懒惰：当正则表达式中包含能接受重复的限定符时，通常的行为是（在使整个表达式能得到匹配的前提下）&lt;code class=&quot;highlighter-rouge&quot;&gt;匹配尽可能多的字符&lt;/code&gt;。有时，我们更需要懒惰匹配，也就是匹配尽可能少的字符。前面给出的限定符都可以被转化为懒惰匹配模式，只要在它后面加上一个问号&lt;code class=&quot;highlighter-rouge&quot;&gt;?&lt;/code&gt;。&lt;/li&gt;
  &lt;li&gt;平衡组/递归匹配&lt;/li&gt;
&lt;/ol&gt;

</description>
        <pubDate>Thu, 10 Aug 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/%E5%9F%BA%E7%A1%80/2017/08/10/regex.html</link>
        <guid isPermaLink="true">http://localhost:4000/%E5%9F%BA%E7%A1%80/2017/08/10/regex.html</guid>
        
        <category>regex</category>
        
        
        <category>基础</category>
        
      </item>
    
      <item>
        <title>[译]在10分钟内解释JavaScript Async/Await</title>
        <description>&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;原文:https://tutorialzine.com/2017/07/javascript-async-await-explained
作者:Danny Markov
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;在很长的一段时间里，JavaScript开发者不得不依靠回调函数去处理异步代码。结果，我们大部分都经历过回调地狱和遇到&lt;a href=&quot;https://tutorialzine.com/media/2017/07/callback-hell.jpg&quot;&gt;这样&lt;/a&gt;功能的恐怖。&lt;/p&gt;

&lt;p&gt;幸运的是，接下来（或者我们应该说 .then()）我们迎来了Promises. 他们提供了一个更组织化的回调方式，大多数社区迅速的转而使用它。&lt;/p&gt;

&lt;p&gt;现在，随着最新版本的Async/Await出现，写JavaScript代码更爽了。&lt;/p&gt;

&lt;h2 id=&quot;什么是asyncawait&quot;&gt;什么是Async/Await？&lt;/h2&gt;

&lt;p&gt;Async/Await是一个很久就令人期待的JavaScript功能，它让使用异步函数更加愉快和容易理解。它是基于Promises的并且和现存的所有基于Promises的API相兼容。&lt;/p&gt;

&lt;p&gt;从async和await这两个名字来的这两个关键字将会帮助我们整理我们的异步代码。&lt;/p&gt;

&lt;p&gt;Async - 声明一个异步函数（async function someName(){…}）。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;自动将一个常规函数转化为一个Promise。&lt;/li&gt;
  &lt;li&gt;当调用async函数的时候，它用函数内返回的任何值来解决（resolve）。&lt;/li&gt;
  &lt;li&gt;异步函数可以使用await&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Await-暂停执行async函数（var result = await someAsyncCall();）。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;当放在一个Promise前面执行，await强制剩下的代码等待直到那个Promise结束并且返回一个结果&lt;/li&gt;
  &lt;li&gt;Await只有和Promise一起使用才有用，和回调函数（普通函数）一起使用不会产生作用&lt;/li&gt;
  &lt;li&gt;Await只可以在async函数内部使用&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这里有一个简单的例子，希望能帮你把事情理清楚：&lt;/p&gt;

&lt;p&gt;假设我们想从我们的服务器中得到一些JSON文件。我们将写一个函数用axios库发送一个http GET 请求到https://tutorialzine.com/misc/files/example.json。 我们不得不等待服务器响应，所以很自然这个HTTP 请求是异步的。&lt;/p&gt;

&lt;p&gt;下面我们可以看到相同的功能实现了两次。首先是用Promises，然后第二次用Async / Await。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// Promise 实现方式
function getJSON(){

    // 为了让函数阻塞我们手动创建了一个Promise
    return new Promise( function(resolve) {
        axios.get('https://tutorialzine.com/misc/files/example.json')
            .then( function(json) {
                // 从请求来的数据可以从.then中得到
                // 我们使用resolve返回结果
                resolve(json);
            });
    });

}

// Async/Await 实现方式
// async关键字将会自动创建一个新的Promise并返回。
async function getJSONAsync(){
    // await关键词使我们免于写一个.then()
    let json = await axios.get('https://tutorialzine.com/misc/files/example.json');
    // GET请求的结果可以从json变量中得到
    // 我们把结果就像一个普通的同步函数一样返回
    return json;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;很明显Async/Await版本的代码更短并且可读性更强。除了使用的语法，两个函数完全相同-他们都返回Promises并且都从axios得到JSON返回。我们可以像这样调用我们的async函数：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;getJSONAsync().then( function(result) {
    // Do something with result.
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;那么asyncawait-让-promises-过时了吗&quot;&gt;那么，Async/Await 让 Promises 过时了吗？&lt;/h2&gt;

&lt;p&gt;一点也不，当我们使用Async/Await其实底层还是在使用Promises。对Promises的良好理解在长远考虑下是对你是十分有帮助的并且也是高度推荐的。&lt;/p&gt;

&lt;p&gt;这里甚至有一些情况Async/Await不能解决而我们不得不重新去寻求Promises的帮助。一种这样的场景是我们需要去调用多个独立的异步函数并等待他们所有完成。&lt;/p&gt;

&lt;p&gt;假如我们尝试用async and await，以下就会发生:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;async function getABC() {
    let A = await getValueA(); // getValueA takes 2 second to finish
    let B = await getValueB(); // getValueB takes 4 second to finish
    let C = await getValueC(); // getValueC takes 3 second to finish
    return A*B*C;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;每一个await将会等待前一个返回一个结果。因为我们一次只执行一个调用那么整个函数从开始到结束将会花9秒的时间（2+4+3）。&lt;/p&gt;

&lt;p&gt;这不是一个最佳的解决方案，因为A,B和C互相并不依赖。换句话来说我们在得到B的时候我们并不需要A的值。我们可以同时得到这些值以减去几秒钟的等待时间。&lt;/p&gt;

&lt;p&gt;同时发送所有的requests我们需要Promise.all()。这将会保证我们在进行下一步的时候我们可以得到所有的结果，但是所有的异步函数将会平行的运行，而不是一个接一个。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;async function getABC() {
  // Promise.all() allows us to send all requests at the same time. 
  let results = await Promise.all([ getValueA, getValueB, getValueC ]); 

  return results.reduce((total,value) =&amp;gt; total * value);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这种方式函数将会花费少的多的时间，在getValueB结束的时候getValueA和getValueC就已经结束了。我们将有效的减少执行的时间到最慢的请求而不是时间的总和。&lt;/p&gt;

&lt;h2 id=&quot;处理asyncawait的错误&quot;&gt;处理Async/Await的错误&lt;/h2&gt;

&lt;p&gt;另一个关于Async/Await很棒的事是它允许我们用很棒的老式try/catch块去catch任何意外的错误。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;async function doSomethingAsync(){
    try {
        // This async call may fail.
        let result = await someAsyncCall();
    }
    catch(error) {
        // If it does we will catch the error here.
    }  
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;任何我们写在try块中的等待的异步调用或者其他任何错误代码，catch都能解决他们引起的错误（error）。&lt;/p&gt;

&lt;p&gt;如果情况需要，我们也可以在执行async函数的时候抓取错误。由于所有异步函数返回Promises，所以我们可以在调用它们时简单地包含.catch()事件处理程序。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 不包含try/catch块的async函数
async function doSomethingAsync(){
    // 这个async调用也许会失败
    let result = await someAsyncCall();
    return result;  
}

// 我们catch错误在调用async函数的时候
doSomethingAsync().
    .then(successHandler)
    .catch(errorHandler);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;重要的是选择一种你喜欢的错误处理的方式，并坚持使用它。同时使用try/catch和.catch(）将很有可能导致一些问题。&lt;/p&gt;

&lt;h2 id=&quot;浏览器支持&quot;&gt;浏览器支持&lt;/h2&gt;

&lt;p&gt;Async/Await已经支持大部分的主流浏览器。绝大多数的厂商将会识别你的async/await代码而不需要额外的库-除了IE11.&lt;/p&gt;

&lt;p&gt;Node开发者只要node8或以上就可以享受到改进的异步流。它在今年晚些时候应该会变成LTS（ Long Term Support ）版本。&lt;/p&gt;

&lt;p&gt;如果这兼容性不能满足你，也有许多像Babel和TypeScript和Nodejs库asyncawait这样的JS transpiler（源码转换器）提供他们自己的跨平台版本的功能。&lt;/p&gt;

&lt;h2 id=&quot;结论&quot;&gt;结论&lt;/h2&gt;

&lt;p&gt;随着Async/Await ，JavaScript语言在代码可读性和易用性上向前迈进了一大步。能够编写类似于常规同步功能的异步代码将会受到JavaScript初学者和经验丰富的编程人员的赞赏。&lt;/p&gt;

</description>
        <pubDate>Sat, 15 Jul 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/js/2017/07/15/AsyncAwaitTran.html</link>
        <guid isPermaLink="true">http://localhost:4000/js/2017/07/15/AsyncAwaitTran.html</guid>
        
        <category>Async</category>
        
        <category>Await</category>
        
        <category>ES6</category>
        
        
        <category>JS</category>
        
      </item>
    
      <item>
        <title>理解JS的this关键字</title>
        <description>&lt;h2 id=&quot;this是什么&quot;&gt;this是什么&lt;/h2&gt;

&lt;p&gt;this是JavaScript中一个关键字，this提供了一种优雅的方式来隐式传递一个对象引用，因此可以把API设计得更加简洁并且易于复用。&lt;br /&gt;
但是，在平常使用中经常会对this产生一些误解，比较常见的会认为this“指向自身”或者“指向函数的作用域”&lt;/p&gt;

&lt;h3 id=&quot;指向自身&quot;&gt;指向自身&lt;/h3&gt;
&lt;p&gt;对于这个误解可以看下以下代码&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function foo(){
    this.a = 1;
}
foo.a = 0;
foo();
console.log(foo.a);//0
console.log(this.a);//1
console.log(window.a);//1
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;通过以上代码可以看到，this并不指向foo而是指向了window，可见this指向自身并不成立&lt;/p&gt;
&lt;h3 id=&quot;指向函数的作用域&quot;&gt;指向函数的作用域&lt;/h3&gt;
&lt;p&gt;这也是个常见的误解,请看一下代码&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function foo(){
    var a = 1;
    bar();
}
function bar(){
    console.log( this.a );
}
foo();//undefined
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;这段代码，希望利用this向上查找到a，代替作用域的效果，但并没有成功。&lt;/p&gt;
&lt;h3 id=&quot;this究竟是什么&quot;&gt;this究竟是什么&lt;/h3&gt;
&lt;p&gt;通过以上一些例子，我们可以看到，this的指向飘忽不定,在不同的场景下，this会化身不同的对象。如果不了解this的机制就很难猜到this的指向。&lt;br /&gt;
那么this究竟是什么？&lt;br /&gt;
&lt;strong&gt;&lt;em&gt;先上结论：实际上，this是在运行的时候进行绑定的，并不是在编写时绑定，它指向什么完全取决于函数在哪里被调用。&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;this绑定规则&quot;&gt;this绑定规则&lt;/h2&gt;
&lt;p&gt;要确定this的值，首先要看函数的调用位置。找到调用位置后，需要判断应用下面四条规则的哪一条&lt;/p&gt;
&lt;h3 id=&quot;默认绑定&quot;&gt;默认绑定&lt;/h3&gt;
&lt;p&gt;这条规则是无法应用其他规则时的默认规则,请看以下代码&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function foo(){
    console.log( this.a );
}
var a = 2;
foo();//2
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;在这里，foo()是直接进行调用，因此只能使用默认绑定，this指向全局对象。&lt;/p&gt;
&lt;h3 id=&quot;隐式绑定&quot;&gt;隐式绑定&lt;/h3&gt;
&lt;p&gt;这种情况是函数是被某个上下文对象调用的，比如下面的代码&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var o = {
    a:3,
    foo:function(){
        console.log(this.a);
    }
}
o.foo();
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;h4 id=&quot;隐式丢失&quot;&gt;隐式丢失&lt;/h4&gt;
&lt;p&gt;隐式绑定一个常见的问题是被隐式绑定的函数会丢失绑定对象，比较常见的情况如下&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function foo(){
    console.log(this.a);
}
function doFoo(fn){
    fn();
}
var obj = {
    a : 2,
    foo : foo
}
var a = &quot;global&quot;;
doFoo(obj.foo);//global
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;这里没有如预想的应用隐式绑定，而是应用了默认绑定，将this绑定到全局对象上了，这种情况在应用隐式绑定的时候经常遇到。&lt;/p&gt;
&lt;h3 id=&quot;显式绑定&quot;&gt;显式绑定&lt;/h3&gt;
&lt;p&gt;显式绑定通过call()或apply()方法，用于显式的指定this的绑定对象&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function foo(){
    console.log(this.a);
}
var obj = {
    a : 2
}
foo.call(obj);// 2
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;h4 id=&quot;硬绑定&quot;&gt;硬绑定&lt;/h4&gt;
&lt;p&gt;但是，显式绑定并没有解决我们之前提出的丢失绑定问题，但是显式绑定的一个变种可以解决这个问题&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function foo(something){
    console.log( this.a,something );
    return this.a + something;
}
function bind(fn,obj){
    return function(){
        return fn.apply(obj,arguments);
    }
}
function doFoo(fn,arg){
    fn(arg);
}
var obj = {
    a:2
};
var bar = bind(foo,obj);
doFoo(bar,3);// 2 3 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;这里，我们创建了一个bind函数用于绑定函数与上下文对象，这种模式称为&lt;em&gt;硬绑定&lt;/em&gt;。&lt;br /&gt;
ES5中提供了内置的bind方法&lt;/p&gt;
&lt;h3 id=&quot;new绑定&quot;&gt;new绑定&lt;/h3&gt;
&lt;p&gt;在JS中，对函数使用new操作符的时候，我们称此函数为构造函数，或者更准确的说，对这个函数进行了“构造调用”。&lt;br /&gt;
使用new来调用函数，会自动执行下面的操作。&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;创建一个全新的对象&lt;/li&gt;
  &lt;li&gt;这个新对象会被执行[[Prototype]]连接(新对象的_proto_指向函数的原型)&lt;/li&gt;
  &lt;li&gt;这个新对象会绑定到函数调用的this&lt;/li&gt;
  &lt;li&gt;如果函数没有返回，自动返回这个新对象&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;new是最后一种可以影响函数调用时this绑定行为的方法，我们称之为new绑定&lt;/p&gt;

&lt;h3 id=&quot;优先级&quot;&gt;优先级&lt;/h3&gt;

&lt;p&gt;现在我们已经了解了函数调用中this绑定的四条规则，你需要做的就是找到函数的调用位置并判断应当应用哪条规则。如果某个调用位置可以应用多条，我们按照优先级应用这四条规则。&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;函数是否在new中调用(new绑定)？如果是的话this绑定的是新创建的对象。&lt;/li&gt;
  &lt;li&gt;函数是否通过call、apply(显式绑定)或者硬绑定调用？如果是的话，this绑定的是指定的对象。&lt;/li&gt;
  &lt;li&gt;函数是否在某个上下文对象中调用(隐式绑定)？如果是的话，this绑定的是那个上下文对象。&lt;/li&gt;
  &lt;li&gt;如果都不是的话，使用默认绑定。如果在严格模式下，就绑定到undefined，否则绑定到全局对象。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;结束&quot;&gt;结束&lt;/h2&gt;
&lt;p&gt;一般情况下通过以上四种规则就可以理解大部分的this的使用情况。当然除了这些一般的情况下也有一些例外，比如ES6的箭头函数中的this会继承外层函数调用的this绑定。碰到这些例外情况就具体情况具体分析了。&lt;/p&gt;

</description>
        <pubDate>Sat, 10 Jun 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/%E5%89%8D%E7%AB%AF/2017/06/10/know_everything_about_this.html</link>
        <guid isPermaLink="true">http://localhost:4000/%E5%89%8D%E7%AB%AF/2017/06/10/know_everything_about_this.html</guid>
        
        <category>this</category>
        
        <category>js</category>
        
        
        <category>前端</category>
        
      </item>
    
      <item>
        <title>毕业了</title>
        <description>&lt;h2 id=&quot;留些纪念&quot;&gt;留些纪念&lt;/h2&gt;

&lt;p&gt;毕业了，心里挺复杂的，但也不是悲伤，愿大家前程似锦。贴些照片留作纪念。&lt;/p&gt;

&lt;h2 id=&quot;照片&quot;&gt;照片&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/img/graduate/9.jpg&quot; alt=&quot;memory&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/graduate/8.jpg&quot; alt=&quot;memory&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/graduate/7.jpg&quot; alt=&quot;memory&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/graduate/6.jpg&quot; alt=&quot;memory&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/graduate/5.jpg&quot; alt=&quot;memory&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/graduate/4.jpg&quot; alt=&quot;memory&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/graduate/3.jpg&quot; alt=&quot;memory&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/graduate/2.jpg&quot; alt=&quot;memory&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/graduate/1.jpg&quot; alt=&quot;memory&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/graduate/10.jpg&quot; alt=&quot;memory&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/graduate/11.jpg&quot; alt=&quot;memory&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/graduate/12.jpg&quot; alt=&quot;memory&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/graduate/13.jpg&quot; alt=&quot;memory&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/graduate/14.jpg&quot; alt=&quot;memory&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/graduate/15.jpg&quot; alt=&quot;memory&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/graduate/16.jpg&quot; alt=&quot;memory&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/graduate/17.jpg&quot; alt=&quot;memory&quot; /&gt;&lt;/p&gt;

&lt;p&gt;诶嘿！哪个是我呢！
&lt;img src=&quot;/img/life/gakki.gif&quot; alt=&quot;memory&quot; /&gt;&lt;/p&gt;

</description>
        <pubDate>Sat, 20 May 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/life/2017/05/20/gra.html</link>
        <guid isPermaLink="true">http://localhost:4000/life/2017/05/20/gra.html</guid>
        
        <category>毕业</category>
        
        <category>记录</category>
        
        
        <category>life</category>
        
      </item>
    
  </channel>
</rss>
