<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>侯星伊的个人博客</title>
    <description>A Simple Jekyll Blog Theme. # this means to ignore newlines until &quot;baseurl:&quot;
</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Sun, 13 Aug 2017 12:05:08 +0800</pubDate>
    <lastBuildDate>Sun, 13 Aug 2017 12:05:08 +0800</lastBuildDate>
    <generator>Jekyll v3.4.3</generator>
    
      <item>
        <title>[译]在10分钟内解释JavaScript Async/Await</title>
        <description>&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;原文:https://tutorialzine.com/2017/07/javascript-async-await-explained
作者:Danny Markov
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;在很长的一段时间里，JavaScript开发者不得不依靠回调函数去处理异步代码。结果，我们大部分都经历过回调地狱和遇到&lt;a href=&quot;https://tutorialzine.com/media/2017/07/callback-hell.jpg&quot;&gt;这样&lt;/a&gt;功能的恐怖。&lt;/p&gt;

&lt;p&gt;幸运的是，接下来（或者我们应该说 .then()）我们迎来了Promises. 他们提供了一个更组织化的回调方式，大多数社区迅速的转而使用它。&lt;/p&gt;

&lt;p&gt;现在，随着最新版本的Async/Await出现，写JavaScript代码更爽了。&lt;/p&gt;

&lt;h2 id=&quot;什么是asyncawait&quot;&gt;什么是Async/Await？&lt;/h2&gt;

&lt;p&gt;Async/Await是一个很久就令人期待的JavaScript功能，它让使用异步函数更加愉快和容易理解。它是基于Promises的并且和现存的所有基于Promises的API相兼容。&lt;/p&gt;

&lt;p&gt;从async和await这两个名字来的这两个关键字将会帮助我们整理我们的异步代码。&lt;/p&gt;

&lt;p&gt;Async - 声明一个异步函数（async function someName(){…}）。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;自动将一个常规函数转化为一个Promise。&lt;/li&gt;
  &lt;li&gt;当调用async函数的时候，它用函数内返回的任何值来解决（resolve）。&lt;/li&gt;
  &lt;li&gt;异步函数可以使用await&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Await-暂停执行async函数（var result = await someAsyncCall();）。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;当放在一个Promise前面执行，await强制剩下的代码等待直到那个Promise结束并且返回一个结果&lt;/li&gt;
  &lt;li&gt;Await只有和Promise一起使用才有用，和回调函数（普通函数）一起使用不会产生作用&lt;/li&gt;
  &lt;li&gt;Await只可以在async函数内部使用&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这里有一个简单的例子，希望能帮你把事情理清楚：&lt;/p&gt;

&lt;p&gt;假设我们想从我们的服务器中得到一些JSON文件。我们将写一个函数用axios库发送一个http GET 请求到https://tutorialzine.com/misc/files/example.json。 我们不得不等待服务器响应，所以很自然这个HTTP 请求是异步的。&lt;/p&gt;

&lt;p&gt;下面我们可以看到相同的功能实现了两次。首先是用Promises，然后第二次用Async / Await。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// Promise 实现方式
function getJSON(){

    // 为了让函数阻塞我们手动创建了一个Promise
    return new Promise( function(resolve) {
        axios.get('https://tutorialzine.com/misc/files/example.json')
            .then( function(json) {
                // 从请求来的数据可以从.then中得到
                // 我们使用resolve返回结果
                resolve(json);
            });
    });

}

// Async/Await 实现方式
// async关键字将会自动创建一个新的Promise并返回。
async function getJSONAsync(){
    // await关键词使我们免于写一个.then()
    let json = await axios.get('https://tutorialzine.com/misc/files/example.json');
    // GET请求的结果可以从json变量中得到
    // 我们把结果就像一个普通的同步函数一样返回
    return json;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;很明显Async/Await版本的代码更短并且可读性更强。除了使用的语法，两个函数完全相同-他们都返回Promises并且都从axios得到JSON返回。我们可以像这样调用我们的async函数：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;getJSONAsync().then( function(result) {
    // Do something with result.
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;那么asyncawait-让-promises-过时了吗&quot;&gt;那么，Async/Await 让 Promises 过时了吗？&lt;/h2&gt;

&lt;p&gt;一点也不，当我们使用Async/Await其实底层还是在使用Promises。对Promises的良好理解在长远考虑下是对你是十分有帮助的并且也是高度推荐的。&lt;/p&gt;

&lt;p&gt;这里甚至有一些情况Async/Await不能解决而我们不得不重新去寻求Promises的帮助。一种这样的场景是我们需要去调用多个独立的异步函数并等待他们所有完成。&lt;/p&gt;

&lt;p&gt;假如我们尝试用async and await，以下就会发生:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;async function getABC() {
    let A = await getValueA(); // getValueA takes 2 second to finish
    let B = await getValueB(); // getValueB takes 4 second to finish
    let C = await getValueC(); // getValueC takes 3 second to finish
    return A*B*C;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;每一个await将会等待前一个返回一个结果。因为我们一次只执行一个调用那么整个函数从开始到结束将会花9秒的时间（2+4+3）。&lt;/p&gt;

&lt;p&gt;这不是一个最佳的解决方案，因为A,B和C互相并不依赖。换句话来说我们在得到B的时候我们并不需要A的值。我们可以同时得到这些值以减去几秒钟的等待时间。&lt;/p&gt;

&lt;p&gt;同时发送所有的requests我们需要Promise.all()。这将会保证我们在进行下一步的时候我们可以得到所有的结果，但是所有的异步函数将会平行的运行，而不是一个接一个。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;async function getABC() {
  // Promise.all() allows us to send all requests at the same time. 
  let results = await Promise.all([ getValueA, getValueB, getValueC ]); 

  return results.reduce((total,value) =&amp;gt; total * value);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这种方式函数将会花费少的多的时间，在getValueB结束的时候getValueA和getValueC就已经结束了。我们将有效的减少执行的时间到最慢的请求而不是时间的总和。&lt;/p&gt;

&lt;h2 id=&quot;处理asyncawait的错误&quot;&gt;处理Async/Await的错误&lt;/h2&gt;

&lt;p&gt;另一个关于Async/Await很棒的事是它允许我们用很棒的老式try/catch块去catch任何意外的错误。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;async function doSomethingAsync(){
    try {
        // This async call may fail.
        let result = await someAsyncCall();
    }
    catch(error) {
        // If it does we will catch the error here.
    }  
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;任何我们写在try块中的等待的异步调用或者其他任何错误代码，catch都能解决他们引起的错误（error）。&lt;/p&gt;

&lt;p&gt;如果情况需要，我们也可以在执行async函数的时候抓取错误。由于所有异步函数返回Promises，所以我们可以在调用它们时简单地包含.catch()事件处理程序。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 不包含try/catch块的async函数
async function doSomethingAsync(){
    // 这个async调用也许会失败
    let result = await someAsyncCall();
    return result;  
}

// 我们catch错误在调用async函数的时候
doSomethingAsync().
    .then(successHandler)
    .catch(errorHandler);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;重要的是选择一种你喜欢的错误处理的方式，并坚持使用它。同时使用try/catch和.catch(）将很有可能导致一些问题。&lt;/p&gt;

&lt;h2 id=&quot;浏览器支持&quot;&gt;浏览器支持&lt;/h2&gt;

&lt;p&gt;Async/Await已经支持大部分的主流浏览器。绝大多数的厂商将会识别你的async/await代码而不需要额外的库-除了IE11.&lt;/p&gt;

&lt;p&gt;Node开发者只要node8或以上就可以享受到改进的异步流。它在今年晚些时候应该会变成LTS（ Long Term Support ）版本。&lt;/p&gt;

&lt;p&gt;如果这兼容性不能满足你，也有许多像Babel和TypeScript和Nodejs库asyncawait这样的JS transpiler（源码转换器）提供他们自己的跨平台版本的功能。&lt;/p&gt;

&lt;h2 id=&quot;结论&quot;&gt;结论&lt;/h2&gt;

&lt;p&gt;随着Async/Await ，JavaScript语言在代码可读性和易用性上向前迈进了一大步。能够编写类似于常规同步功能的异步代码将会受到JavaScript初学者和经验丰富的编程人员的赞赏。&lt;/p&gt;

</description>
        <pubDate>Sat, 15 Jul 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/js/2017/07/15/AsyncAwaitTran.html</link>
        <guid isPermaLink="true">http://localhost:4000/js/2017/07/15/AsyncAwaitTran.html</guid>
        
        <category>Async</category>
        
        <category>Await</category>
        
        <category>ES6</category>
        
        
        <category>JS</category>
        
      </item>
    
      <item>
        <title>理解JS的this关键字</title>
        <description>&lt;h2 id=&quot;this是什么&quot;&gt;this是什么&lt;/h2&gt;

&lt;p&gt;this是JavaScript中一个关键字，this提供了一种优雅的方式来隐式传递一个对象引用，因此可以把API设计得更加简洁并且易于复用。&lt;br /&gt;
但是，在平常使用中经常会对this产生一些误解，比较常见的会认为this“指向自身”或者“指向函数的作用域”&lt;/p&gt;

&lt;h3 id=&quot;指向自身&quot;&gt;指向自身&lt;/h3&gt;
&lt;p&gt;对于这个误解可以看下以下代码&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function foo(){
    this.a = 1;
}
foo.a = 0;
foo();
console.log(foo.a);//0
console.log(this.a);//1
console.log(window.a);//1
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;通过以上代码可以看到，this并不指向foo而是指向了window，可见this指向自身并不成立&lt;/p&gt;
&lt;h3 id=&quot;指向函数的作用域&quot;&gt;指向函数的作用域&lt;/h3&gt;
&lt;p&gt;这也是个常见的误解,请看一下代码&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function foo(){
    var a = 1;
    bar();
}
function bar(){
    console.log( this.a );
}
foo();//undefined
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;这段代码，希望利用this向上查找到a，代替作用域的效果，但并没有成功。&lt;/p&gt;
&lt;h3 id=&quot;this究竟是什么&quot;&gt;this究竟是什么&lt;/h3&gt;
&lt;p&gt;通过以上一些例子，我们可以看到，this的指向飘忽不定,在不同的场景下，this会化身不同的对象。如果不了解this的机制就很难猜到this的指向。&lt;br /&gt;
那么this究竟是什么？&lt;br /&gt;
&lt;strong&gt;&lt;em&gt;先上结论：实际上，this是在运行的时候进行绑定的，并不是在编写时绑定，它指向什么完全取决于函数在哪里被调用。&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;this绑定规则&quot;&gt;this绑定规则&lt;/h2&gt;
&lt;p&gt;要确定this的值，首先要看函数的调用位置。找到调用位置后，需要判断应用下面四条规则的哪一条&lt;/p&gt;
&lt;h3 id=&quot;默认绑定&quot;&gt;默认绑定&lt;/h3&gt;
&lt;p&gt;这条规则是无法应用其他规则时的默认规则,请看以下代码&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function foo(){
    console.log( this.a );
}
var a = 2;
foo();//2
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;在这里，foo()是直接进行调用，因此只能使用默认绑定，this指向全局对象。&lt;/p&gt;
&lt;h3 id=&quot;隐式绑定&quot;&gt;隐式绑定&lt;/h3&gt;
&lt;p&gt;这种情况是函数是被某个上下文对象调用的，比如下面的代码&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var o = {
    a:3,
    foo:function(){
        console.log(this.a);
    }
}
o.foo();
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;h4 id=&quot;隐式丢失&quot;&gt;隐式丢失&lt;/h4&gt;
&lt;p&gt;隐式绑定一个常见的问题是被隐式绑定的函数会丢失绑定对象，比较常见的情况如下&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function foo(){
    console.log(this.a);
}
function doFoo(fn){
    fn();
}
var obj = {
    a : 2,
    foo : foo
}
var a = &quot;global&quot;;
doFoo(obj.foo);//global
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;这里没有如预想的应用隐式绑定，而是应用了默认绑定，将this绑定到全局对象上了，这种情况在应用隐式绑定的时候经常遇到。&lt;/p&gt;
&lt;h3 id=&quot;显式绑定&quot;&gt;显式绑定&lt;/h3&gt;
&lt;p&gt;显式绑定通过call()或apply()方法，用于显式的指定this的绑定对象&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function foo(){
    console.log(this.a);
}
var obj = {
    a : 2
}
foo.call(obj);// 2
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;h4 id=&quot;硬绑定&quot;&gt;硬绑定&lt;/h4&gt;
&lt;p&gt;但是，显式绑定并没有解决我们之前提出的丢失绑定问题，但是显式绑定的一个变种可以解决这个问题&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function foo(something){
    console.log( this.a,something );
    return this.a + something;
}
function bind(fn,obj){
    return function(){
        return fn.apply(obj,arguments);
    }
}
function doFoo(fn,arg){
    fn(arg);
}
var obj = {
    a:2
};
var bar = bind(foo,obj);
doFoo(bar,3);// 2 3 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;这里，我们创建了一个bind函数用于绑定函数与上下文对象，这种模式称为&lt;em&gt;硬绑定&lt;/em&gt;。&lt;br /&gt;
ES5中提供了内置的bind方法&lt;/p&gt;
&lt;h3 id=&quot;new绑定&quot;&gt;new绑定&lt;/h3&gt;
&lt;p&gt;在JS中，对函数使用new操作符的时候，我们称此函数为构造函数，或者更准确的说，对这个函数进行了“构造调用”。&lt;br /&gt;
使用new来调用函数，会自动执行下面的操作。&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;创建一个全新的对象&lt;/li&gt;
  &lt;li&gt;这个新对象会被执行[[Prototype]]连接(新对象的_proto_指向函数的原型)&lt;/li&gt;
  &lt;li&gt;这个新对象会绑定到函数调用的this&lt;/li&gt;
  &lt;li&gt;如果函数没有返回，自动返回这个新对象&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;new是最后一种可以影响函数调用时this绑定行为的方法，我们称之为new绑定&lt;/p&gt;

&lt;h3 id=&quot;优先级&quot;&gt;优先级&lt;/h3&gt;

&lt;p&gt;现在我们已经了解了函数调用中this绑定的四条规则，你需要做的就是找到函数的调用位置并判断应当应用哪条规则。如果某个调用位置可以应用多条，我们按照优先级应用这四条规则。&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;函数是否在new中调用(new绑定)？如果是的话this绑定的是新创建的对象。&lt;/li&gt;
  &lt;li&gt;函数是否通过call、apply(显式绑定)或者硬绑定调用？如果是的话，this绑定的是指定的对象。&lt;/li&gt;
  &lt;li&gt;函数是否在某个上下文对象中调用(隐式绑定)？如果是的话，this绑定的是那个上下文对象。&lt;/li&gt;
  &lt;li&gt;如果都不是的话，使用默认绑定。如果在严格模式下，就绑定到undefined，否则绑定到全局对象。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;结束&quot;&gt;结束&lt;/h2&gt;
&lt;p&gt;一般情况下通过以上四种规则就可以理解大部分的this的使用情况。当然除了这些一般的情况下也有一些例外，比如ES6的箭头函数中的this会继承外层函数调用的this绑定。碰到这些例外情况就具体情况具体分析了。&lt;/p&gt;

</description>
        <pubDate>Sat, 10 Jun 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/%E5%89%8D%E7%AB%AF/2017/06/10/know_everything_about_this.html</link>
        <guid isPermaLink="true">http://localhost:4000/%E5%89%8D%E7%AB%AF/2017/06/10/know_everything_about_this.html</guid>
        
        <category>this</category>
        
        <category>js</category>
        
        
        <category>前端</category>
        
      </item>
    
      <item>
        <title>毕业了</title>
        <description>&lt;h2 id=&quot;留些纪念&quot;&gt;留些纪念&lt;/h2&gt;

&lt;p&gt;毕业了，心里挺复杂的，但也不是悲伤，愿大家前程似锦。贴些照片留作纪念。&lt;/p&gt;

&lt;h2 id=&quot;照片&quot;&gt;照片&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/img/graduate/9.jpg&quot; alt=&quot;memory&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/graduate/8.jpg&quot; alt=&quot;memory&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/graduate/7.jpg&quot; alt=&quot;memory&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/graduate/6.jpg&quot; alt=&quot;memory&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/graduate/5.jpg&quot; alt=&quot;memory&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/graduate/4.jpg&quot; alt=&quot;memory&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/graduate/3.jpg&quot; alt=&quot;memory&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/graduate/2.jpg&quot; alt=&quot;memory&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/graduate/1.jpg&quot; alt=&quot;memory&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/graduate/10.jpg&quot; alt=&quot;memory&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/graduate/11.jpg&quot; alt=&quot;memory&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/graduate/12.jpg&quot; alt=&quot;memory&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/graduate/13.jpg&quot; alt=&quot;memory&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/graduate/14.jpg&quot; alt=&quot;memory&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/graduate/15.jpg&quot; alt=&quot;memory&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/graduate/16.jpg&quot; alt=&quot;memory&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/graduate/17.jpg&quot; alt=&quot;memory&quot; /&gt;&lt;/p&gt;

&lt;p&gt;诶嘿！哪个是我呢！
&lt;img src=&quot;/img/life/gakki.gif&quot; alt=&quot;memory&quot; /&gt;&lt;/p&gt;

</description>
        <pubDate>Sat, 20 May 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/life/2017/05/20/gra.html</link>
        <guid isPermaLink="true">http://localhost:4000/life/2017/05/20/gra.html</guid>
        
        <category>毕业</category>
        
        <category>记录</category>
        
        
        <category>life</category>
        
      </item>
    
  </channel>
</rss>
