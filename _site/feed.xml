<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>侯星伊的个人博客</title>
    <description>A Simple Jekyll Blog Theme. # this means to ignore newlines until &quot;baseurl:&quot;
</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Thu, 30 Nov 2017 11:14:39 +0800</pubDate>
    <lastBuildDate>Thu, 30 Nov 2017 11:14:39 +0800</lastBuildDate>
    <generator>Jekyll v3.4.3</generator>
    
      <item>
        <title>js异步编程解决方案</title>
        <description>&lt;p&gt;在JavaScript中，函数作为一等公民，使用上非常自由，无论调用，或者作为参数，或者作为返回值均可。&lt;/p&gt;

&lt;p&gt;于是在无论是前端的事件驱动回调函数中，还是在nodejs中的异步IO，我们可以看见大量的回调函数。所谓的回调函数，就是把函数作为参数传入，并在将来的某个时候”回头调用”。&lt;/p&gt;

&lt;p&gt;回调函数通常作为异步编程的一个解决方案，但是回调函数有许多问题&lt;/p&gt;

&lt;h2 id=&quot;回调函数的问题&quot;&gt;回调函数的问题&lt;/h2&gt;

&lt;h3 id=&quot;问题一回调地狱&quot;&gt;问题一：回调地狱&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var fs = require('fs');
fs.readFile('./text1.txt', 'utf8', function(err, data){
    console.log(&quot;text1 file content: &quot; + data);
    fs.readFile('./text2.txt', 'utf8', function(err, data){
        console.log(&quot;text2 file content: &quot; + data);
    });
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;上面是我们在进行nodejs编程的时候经常会遇见的场景。前端进行异步请求的时候也经常会遇见这样的场景。当回调嵌套过深的时候，就会出现以下场景。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;doSomethingAsync1(function(){
    doSomethingAsync2(function(){
        doSomethingAsync3(function(){
            doSomethingAsync4(function(){
               doSomethingAsync5(function(){
                    // code...
                });
            });
        });
    });
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;所以这种嵌套过深的情况有时候是不可忍受的，我们称之为“回调地狱”或“回调金字塔”&lt;/p&gt;

&lt;h3 id=&quot;问题二异步编程的理解&quot;&gt;问题二：异步编程的理解&lt;/h3&gt;

&lt;p&gt;我们的大脑习惯顺序思考问题，当要做一件事情的时候，我们会思考先做A再做B然后做C…。然而用回调函数写的异步代码则违反了我们天生的思考原则。&lt;/p&gt;

&lt;p&gt;你能够很快的说出以下代码的执行顺序吗。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;doA(function(){
    doC();

    doD(function(){
        doF();
    })

    doE();
})

doB();
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;对于这样的代码，我们需要很大的努力才可以理解。也就是说，可读性很差。&lt;/p&gt;

&lt;h2 id=&quot;回调函数的代替解决方案&quot;&gt;回调函数的代替解决方案&lt;/h2&gt;

&lt;h3 id=&quot;拆解function&quot;&gt;拆解function&lt;/h3&gt;

&lt;p&gt;我们可以通过将各部分的任务拆解为单个函数&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function getData(count) {
    get(`/sampleget?count=${count}`, data =&amp;gt; {
        console.log(data);
    });
}

function queryDB(kw) {
    db.find(`select * from sample where kw = ${kw}`, (err, res) =&amp;gt; {
        getData(res.length);
    });
}

function readFile(filepath) {
    fs.readFile(filepath, 'utf-8', (err, content) =&amp;gt; {
        let keyword = content.substring(0, 5);
        queryDB(keyword);
    });
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;事件发布订阅模式&quot;&gt;事件发布/订阅模式&lt;/h3&gt;

&lt;p&gt;采用发布订阅模式进行解耦&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;const events = require('events');
const eventEmitter = new events.EventEmitter();

eventEmitter.on('db', (err, kw) =&amp;gt; {
    db.find(`select * from sample where kw = ${kw}`, (err, res) =&amp;gt; {
        eventEmitter('get', res.length);
    });
});

eventEmitter.on('get', (err, count) =&amp;gt; {
    get(`/sampleget?count=${count}`, data =&amp;gt; {
        console.log(data);
    });
});

fs.readFile('./sample.txt', 'utf-8', (err, content) =&amp;gt; {
    let keyword = content.substring(0, 5);
    eventEmitter. emit('db', keyword);
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;以上两种解决方案确实可以解决一定问题，但终究没有摆脱回调函数的模式。&lt;/p&gt;

&lt;h3 id=&quot;promise&quot;&gt;Promise&lt;/h3&gt;

&lt;p&gt;ES 6中原生提供了Promise对象，Promise对象代表了某个未来才会知道结果的事件(一般是一个异步操作)，并且这个事件对外提供了统一的API，可供进一步处理。&lt;/p&gt;

&lt;p&gt;使用Promise对象可以用同步操作的流程写法来表达异步操作，避免了层层嵌套的异步回调，代码也更加清晰易懂，方便维护。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var fs = require('fs')
var read = function (filename){
    var promise = new Promise(function(resolve, reject){
        fs.readFile(filename, 'utf8', function(err, data){
            if (err){
                reject(err);
            }
            resolve(data);
        })
    });
    return promise;
}
read('./text1.txt')
.then(function(data){
    console.log(data);
return read('./text2.txt');
})
.then(function(data){
    console.log(data);
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;h3 id=&quot;generator&quot;&gt;Generator&lt;/h3&gt;

&lt;p&gt;Generator 函数有多种理解角度。语法上，首先可以把它理解成，Generator 函数是一个状态机，封装了多个内部状态。&lt;/p&gt;

&lt;p&gt;执行 Generator 函数会返回一个遍历器对象，也就是说，Generator 函数除了状态机，还是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历 Generator 函数内部的每一个状态。&lt;/p&gt;

&lt;p&gt;形式上，Generator 函数是一个普通函数，但是有两个特征。一是，function关键字与函数名之间有一个星号；二是，函数体内部使用yield表达式，定义不同的内部状态（yield在英语里的意思就是“产出”）。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function* helloWorldGenerator() {
  yield 'hello';
  yield 'world';
  yield 'end';
  return 'ending';
}
hw.next()
// { value: 'hello', done: false }

hw.next()
// { value: 'world', done: false }

hw.next()
// { value: 'end', done: true }

hw.next()
// { value: undefined, done: true }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;上面代码定义了一个 Generator 函数helloWorldGenerator，它内部有三个yield表达式（hello和world、end），即该函数有三个状态：hello，world，end 和 return 语句（结束执行）。&lt;/p&gt;

&lt;p&gt;然后，Generator 函数的调用方法与普通函数一样，也是在函数名后面加上一对圆括号。不同的是，调用 Generator 函数后，该&lt;code class=&quot;highlighter-rouge&quot;&gt;函数并不执行&lt;/code&gt;，返回的也不是函数运行结果，而是一个指向内部状态的指针对象，也就是遍历器对象（Iterator Object）。&lt;/p&gt;

&lt;p&gt;下一步，必须调用遍历器对象的next方法，使得指针移向下一个状态。也就是说，每次调用next方法，内部指针就从函数头部或上一次停下来的地方开始执行，直到遇到下一个yield表达式（或return语句）为止。换言之，Generator 函数是分段执行的，yield表达式是暂停执行的标记，而next方法可以恢复执行。&lt;/p&gt;

&lt;h2 id=&quot;asyncawait&quot;&gt;async/await&lt;/h2&gt;

&lt;p&gt;async/await是ES7中的异步解决方案，可以看我的这篇博文。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://houxingyi.github.io/js/2017/07/15/AsyncAwaitTran.html&quot;&gt;[译]在10分钟内解释JavaScript Async/Await&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;结尾&quot;&gt;结尾&lt;/h2&gt;

&lt;p&gt;结合以上，我们可以有五种方法来解决回调地狱的问题&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;拆解function&lt;/li&gt;
  &lt;li&gt;事件发布/订阅模式&lt;/li&gt;
  &lt;li&gt;Promise&lt;/li&gt;
  &lt;li&gt;Generator&lt;/li&gt;
  &lt;li&gt;async/await&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Thu, 02 Nov 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/js/2017/11/02/async.html</link>
        <guid isPermaLink="true">http://localhost:4000/js/2017/11/02/async.html</guid>
        
        <category>异步编程</category>
        
        
        <category>js</category>
        
      </item>
    
      <item>
        <title>mongoose之Population</title>
        <description>&lt;p&gt;在MongoDB中没有关系型数据库的join特性，所以在document进行相互关联的时候就比较麻烦。&lt;/p&gt;

&lt;p&gt;在mongoose中有一个&lt;code class=&quot;highlighter-rouge&quot;&gt;population&lt;/code&gt;用于解决这类问题。在定义&lt;code class=&quot;highlighter-rouge&quot;&gt;Schema&lt;/code&gt;的时候，如果设置某个&lt;code class=&quot;highlighter-rouge&quot;&gt;field&lt;/code&gt;关联另一个&lt;code class=&quot;highlighter-rouge&quot;&gt;Schema&lt;/code&gt;，那么在获取&lt;code class=&quot;highlighter-rouge&quot;&gt;document&lt;/code&gt;的时候就可以使用&lt;code class=&quot;highlighter-rouge&quot;&gt;Population&lt;/code&gt;功能通过关联&lt;code class=&quot;highlighter-rouge&quot;&gt;Schema&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;field&lt;/code&gt;找到关联的另一个&lt;code class=&quot;highlighter-rouge&quot;&gt;document&lt;/code&gt;，并且用被关联&lt;code class=&quot;highlighter-rouge&quot;&gt;document&lt;/code&gt;的内容替换掉原来关联&lt;code class=&quot;highlighter-rouge&quot;&gt;field&lt;/code&gt;的内容。&lt;/p&gt;

&lt;h2 id=&quot;例子&quot;&gt;例子&lt;/h2&gt;

&lt;p&gt;下面我拿官方的例子来说明&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var mongoose = require('mongoose');
var Schema = mongoose.Schema;

var personSchema = Schema({
  _id: Schema.Types.ObjectId,
  name: String,
  age: Number,
  stories: [{ type: Schema.Types.ObjectId, ref: 'Story' }]
});

var storySchema = Schema({
  author: { type: Schema.Types.ObjectId, ref: 'Person' },
  title: String,
  fans: [{ type: Schema.Types.ObjectId, ref: 'Person' }]
});

var Story = mongoose.model('Story', storySchema);
var Person = mongoose.model('Person', personSchema);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;首先先定义两个model，并且这两个model的schema相互引用。可以看到在person的stories字段（field ）中我们定义了数组，表示关联的数据解析为数组。其中ref选项告诉mongoose在使用populate的时候使用什么model，并且后续所有的传入的_id都要在这个model之中。&lt;/p&gt;

&lt;h2 id=&quot;保存数据&quot;&gt;保存数据&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var author = new Person({
  _id: new mongoose.Types.ObjectId(),
  name: 'Ian Fleming',
  age: 50
});

author.save(function (err) {
  if (err) return handleError(err);
  
  var story1 = new Story({
    title: 'Casino Royale',
    author: author._id    // assign the _id from the person
  });
  
  story1.save(function (err) {
    if (err) return handleError(err);
    // thats it!
  });
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;保存数据的时候并没有什么不同，只是记得要分配下_id，若是_ids,则把所有需要展现的document的_id做成一个数组传入。&lt;/p&gt;

&lt;h2 id=&quot;解析出引用&quot;&gt;解析出引用&lt;/h2&gt;

&lt;p&gt;上面做的一些操作并没有什么特别的，但接下来我们可以看到通过populate我们解析除了内嵌的关联document。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Story.
  findOne({ title: 'Casino Royale' }).
  populate('author').
  exec(function (err, story) {
    if (err) return handleError(err);
    console.log('The author is %s', story.author.name);
    // prints &quot;The author is Ian Fleming&quot;
  });
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;下面我说下populate方法的常用用法&lt;/p&gt;

&lt;h2 id=&quot;querypopulate&quot;&gt;Query#populate&lt;/h2&gt;

&lt;p&gt;就是查询语句之后可以调用populate&lt;/p&gt;

&lt;p&gt;语法&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;**`Query.populate(path, [select], [model], [match], [options])`**
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;参数&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;path&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;类型：&lt;code class=&quot;highlighter-rouge&quot;&gt;String&lt;/code&gt;或&lt;code class=&quot;highlighter-rouge&quot;&gt;Object&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;String类型的时， 指定要填充的关联字段，要填充多个关联字段可以以空格分隔。&lt;/p&gt;

&lt;p&gt;Object类型的时，就是把 populate 的参数封装到一个对象里。当然也可以是个数组。下面的例子中将会实现。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;select&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;类型：&lt;code class=&quot;highlighter-rouge&quot;&gt;Object&lt;/code&gt;或&lt;code class=&quot;highlighter-rouge&quot;&gt;String&lt;/code&gt;，可选，指定填充 document 中的哪些字段。&lt;/p&gt;

&lt;p&gt;Object类型的时，格式如:{name: 1, _id: 0},为0表示不填充，为1时表示填充。
　　
String类型的时，格式如:”name -_id”，用空格分隔字段，在字段名前加上-表示不填充。详细语法介绍 query-select&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;model&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;类型：Model，可选，指定关联字段的 model，如果没有指定就会使用Schema的ref。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;match&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;类型：Object，可选，指定附加的查询条件。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;options&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;类型：Object，可选，指定附加的其他查询选项，如排序以及条数限制等等。&lt;/p&gt;

&lt;p&gt;例子&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//填充所有 users 的 posts
User.find()
    .populate('posts', 'title', null, {sort: { title: -1 }})
    .exec(function(err, docs) {
        console.log(docs[0].posts[0].title); // post-by-aikin
    });

//填充 user 'luajin'的 posts
User.findOne({name: 'luajin'})
    .populate({path: 'posts', select: { title: 1 }, options: {sort: { title: -1 }}})
    .exec(function(err, doc) {
        console.log(doc.posts[0].title);  // post-by-luajin
    });

//这里的 populate 方法传入的参数形式不同，其实实现的功能是一样的，只是表示形式不一样。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;modelpopulate&quot;&gt;Model#populate&lt;/h2&gt;

&lt;p&gt;model直接调用populate&lt;/p&gt;

&lt;p&gt;语法&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;**`Model.populate(docs, options, [cb(err,doc)])`**
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;参数&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;docs&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;类型：Document或Array。单个需要被填充的 doucment 或者 document 的数组。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;options&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;类型：Object。以键值对的形式表示。&lt;/p&gt;

&lt;p&gt;keys：path select match model options，这些键对应值的类型和功能，与上述Query#populate方法的参数相同。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;[cb(err,doc)]&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;类型：Function，回调函数，接收两个参数，错误err和填充完的doc(s)。&lt;/p&gt;

&lt;p&gt;例子&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Post.find({title: 'post-by-aikin'})
    .populate('poster comments')
    .exec(function(err, docs) {

        var opts = [{
            path   : 'comments.commenter',
            select : 'name',
            model  : 'User'
        }];

        Post.populate(docs, opts, function(err, populatedDocs) {
            console.log(populatedDocs[0].poster.name);                  // aikin
            console.log(populatedDocs[0].comments[0].commenter.name);  // luna
        });
    });
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;documentpopulate&quot;&gt;Document#populate&lt;/h2&gt;

&lt;p&gt;document直接调用populate&lt;/p&gt;

&lt;p&gt;语法&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;**`Document.populate([path], [callback])`**
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;参数&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;path&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;类型：String或Object。与上述Query#populate`方法的 path 参数相同。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;callback&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;类型：Function。回调函数，接收两个参数，错误err和填充完的doc(s)。&lt;/p&gt;

&lt;p&gt;例子&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;User.findOne({name: 'aikin'})
    .exec(function(err, doc) {

        var opts = [{
            path   : 'posts',
            select : 'title'
        }];

        doc.populate(opts, function(err, populatedDoc) {
            console.log(populatedDoc.posts[0].title);  // post-by-aikin
        });
    });
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;跨越等级的populate&quot;&gt;跨越等级的Populate&lt;/h2&gt;

&lt;p&gt;populate可以进行多重引用&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var userSchema = new Schema({
  name: String,
  friends: [{ type: ObjectId, ref: 'User' }]
});

User.
  findOne({ name: 'Val' }).
  populate({
    path: 'friends',
    // Get friends of friends - populate the 'friends' array for every friend
    populate: { path: 'friends' }
  });
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;参考&quot;&gt;参考&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;http://mongoosejs.com/docs/populate.html&quot;&gt;官方starter&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000002727265&quot;&gt;Mongoose 之 Population 使用&lt;/a&gt;&lt;/p&gt;

</description>
        <pubDate>Mon, 30 Oct 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/mongodb/2017/10/30/populate.html</link>
        <guid isPermaLink="true">http://localhost:4000/mongodb/2017/10/30/populate.html</guid>
        
        <category>mongoose</category>
        
        <category>populate</category>
        
        
        <category>mongoDB</category>
        
      </item>
    
      <item>
        <title>用Vuex来做vue应用的状态管理</title>
        <description>&lt;h2 id=&quot;什么是vuex&quot;&gt;什么是Vuex&lt;/h2&gt;

&lt;p&gt;Vuex是一个专为Vue.js应用程序开发的状态管理模式。&lt;/p&gt;

&lt;p&gt;当我们的Vue应用越来越大的时候，有一些公用部分的状态不好管理，比如多重组件嵌套等。这时候，我们就可以用Vuex来进行统一的应用状态管理。&lt;/p&gt;

&lt;h2 id=&quot;核心概念&quot;&gt;核心概念&lt;/h2&gt;

&lt;h3 id=&quot;state-读&quot;&gt;State (读)&lt;/h3&gt;

&lt;p&gt;State是唯一的数据源，单一状态树&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;this.$store.state.count&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;mutations-写&quot;&gt;Mutations (写)&lt;/h3&gt;
&lt;p&gt;更改Vuex的store中的状态的&lt;code class=&quot;highlighter-rouge&quot;&gt;唯一方法&lt;/code&gt;是提交mutation,Mutation 必须是同步函数。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mutations: {
  increment (state, payload) {
    state.count += payload.amount
  }
}
store.commit('increment', {
  amount: 10
})
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;actions&quot;&gt;Actions&lt;/h3&gt;
&lt;p&gt;Action 类似于 mutation，不同在于:Action提交的是mutation，而不是直接变更状态,Action可以包含任意异步操作&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;const store = new Vuex.Store({
  state: {
    count: 0
  },
  mutations: {
    increment (state) {
      state.count++
    }
  },
  actions: {
    increment (context) {
      context.commit('increment')
    }
  }
})
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;getters&quot;&gt;Getters&lt;/h3&gt;
&lt;p&gt;通过Getters可以派生出一些新的状态（在state的基础上）&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;const store = new Vuex.Store({
  state: {
    todos: [
      { id: 1, text: '...', done: true },
      { id: 2, text: '...', done: false }
    ]
  },
  getters: {
    doneTodos: state =&amp;gt; {
      return state.todos.filter(todo =&amp;gt; todo.done)
    }
  }
})
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;modules&quot;&gt;Modules&lt;/h3&gt;
&lt;p&gt;面对复杂的应用程序，当管理的状态比较多时，我们需要将Vuex的store对象分割成模块(modules)。&lt;/p&gt;

&lt;h2 id=&quot;例子&quot;&gt;例子&lt;/h2&gt;

&lt;p&gt;你可以通过 store.state 来获取状态对象，以及通过 store.commit 方法触发状态变更。&lt;/p&gt;

&lt;p&gt;最主要的是store是全局的&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Vue.use(Vuex);

const store = new Vuex.Store({
  state: {
    count: 0
  },
  mutations: {
  	increment: state =&amp;gt; state.count++,
    decrement: state =&amp;gt; state.count--
  }
})

new Vue({
  el: '#app',
  computed: {
    count () {
	    return store.state.count
    }
  },
  methods: {
    increment () {
      store.commit('increment')
    },
    decrement () {
    	store.commit('decrement')
    }
  }
})
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
        <pubDate>Sun, 29 Oct 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/vue/2017/10/29/vuex.html</link>
        <guid isPermaLink="true">http://localhost:4000/vue/2017/10/29/vuex.html</guid>
        
        <category>vuex</category>
        
        
        <category>vue</category>
        
      </item>
    
      <item>
        <title>mongoDB常用操作</title>
        <description>&lt;p&gt;一些mongoDB常用的操作&lt;/p&gt;

&lt;h2 id=&quot;基本概念&quot;&gt;基本概念&lt;/h2&gt;

&lt;p&gt;mongoDB中的一些基本概念与SQL的基本概念是不同的，这是我们学习mongoDB的时候需要注意与区分的。 &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;下面一个表格带我们来理解下mongoDB中的一些概念。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;SQL概念&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;mongoDB概念&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;说明&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;database&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;database&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;数据库&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;table&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;collection&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;数据库表/集合&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;row&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;document&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;数据记录行/文档&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;column&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;field&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;数据字段/域&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;index&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;index&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;索引&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;table joins&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;表连接，mongoDB不支持&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;primary key&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;primary key&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;主键，mongoDB自动将_id字段设置为主键&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;通过下图，更加直观的理解mongoDB的一些概念&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;./show.png&quot; alt=&quot;展示&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;数据库&quot;&gt;数据库&lt;/h3&gt;

&lt;p&gt;一个mongoDB可以建立多个数据库&lt;/p&gt;

&lt;p&gt;通过命令show dbs来展现当前有多少数据库，名字分别叫什么&lt;/p&gt;

&lt;h3 id=&quot;文档document&quot;&gt;文档（document）&lt;/h3&gt;

&lt;p&gt;在mongoDB中文档就是一组键值对(key-value)。MongoDB 的文档不需要设置相同的字段，并且相同的字段不需要相同的数据类型，这与关系型数据库有很大的区别，也是 MongoDB 非常突出的特点。&lt;/p&gt;

&lt;p&gt;需要注意的点&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;文档中的键/值对是有序的。&lt;/li&gt;
  &lt;li&gt;文档中的值不仅可以是在双引号里面的字符串，还可以是其他几种数据类型（甚至可以是整个嵌入的文档)。&lt;/li&gt;
  &lt;li&gt;MongoDB区分类型和大小写。&lt;/li&gt;
  &lt;li&gt;MongoDB的文档不能有重复的键。&lt;/li&gt;
  &lt;li&gt;文档的键是字符串。除了少数例外情况，键可以使用任意UTF-8字符。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;集合collection&quot;&gt;集合（collection）&lt;/h3&gt;

&lt;p&gt;集合就是mongoDB文档组，类似关系型数据库中的表。一个数据库中有多个集合，可以用命令show collections来查看。集合没有固定的结构，这意味着你在对集合可以插入不同格式和类型的数据，但通常情况下我们插入集合的数据都会有一定的关联性。&lt;/p&gt;

&lt;h3 id=&quot;mongodb-数据类型&quot;&gt;MongoDB 数据类型&lt;/h3&gt;

&lt;p&gt;下表为MongoDB中常用的几种数据类型。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;SQL概念&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;mongoDB概念&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;String&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;字符串。存储数据常用的数据类型。在 MongoDB 中，UTF-8 编码的字符串才是合法的。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Integer&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;整型数值。用于存储数值。根据你所采用的服务器，可分为 32 位或 64 位。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Boolean&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;布尔值。用于存储布尔值（真/假）。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Double&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;双精度浮点值。用于存储浮点值。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Min/Max keys&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;将一个值与 BSON（二进制的 JSON）元素的最低值和最高值相对比。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Array&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;用于将数组或列表或多个值存储为一个键。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Timestamp&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;时间戳。记录文档修改或添加的具体时间。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Object&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;用于内嵌文档。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Null&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;用于创建空值。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Symbol&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;符号。该数据类型基本上等同于字符串类型，但不同的是，它一般用于采用特殊符号类型的语言。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Date&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;日期时间。用 UNIX 时间格式来存储当前日期或时间。你可以指定自己的日期时间：创建 Date 对象，传入年月日信息。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Object ID&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;对象 ID。用于创建文档的 ID。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Binary Data&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;二进制数据。用于存储二进制数据。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Code&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;代码类型。用于在文档中存储 JavaScript 代码。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Regular expression&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;正则表达式类型。用于存储正则表达式。&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;创建数据库&quot;&gt;创建数据库&lt;/h2&gt;

&lt;p&gt;直接使用use命令创建数据库。如果数据库不存在，则创建数据库，否则切换到指定数据库。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;use DATABASE_NAME
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;使用show dbs展示当前已创建的数据库。&lt;/p&gt;

&lt;p&gt;use数据库之后db命令表示当前数据库&lt;/p&gt;

&lt;h2 id=&quot;删除数据库&quot;&gt;删除数据库&lt;/h2&gt;

&lt;p&gt;使用下列命令删除数据库&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;db.dropDatabase()
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;使用下列命令删除集合&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;db.collection.drop()
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;插入数据&quot;&gt;插入数据&lt;/h2&gt;

&lt;p&gt;MongoDB 使用 insert() 或 save() 方法向集合中插入文档，语法如下：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;db.COLLECTION_NAME.insert(document)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;document采用json语法&lt;/p&gt;

&lt;p&gt;3.2 版本后还有以下几种语法可用于插入文档:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;db.collection.insertOne():向指定集合中插入一条文档数据&lt;/li&gt;
  &lt;li&gt;db.collection.insertMany():向指定集合中插入多条文档数据&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;更新文档&quot;&gt;更新文档&lt;/h2&gt;

&lt;p&gt;update() 方法用于更新已存在的文档。语法格式如下：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;db.collection.update(
   &amp;lt;query&amp;gt;,
   &amp;lt;update&amp;gt;,
   {
     upsert: &amp;lt;boolean&amp;gt;,
     multi: &amp;lt;boolean&amp;gt;,
     writeConcern: &amp;lt;document&amp;gt;
   }
)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;参数说明：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;query : update的查询条件，类似sql update查询内where后面的。&lt;/li&gt;
  &lt;li&gt;update : update的对象和一些更新的操作符（如$,$inc…）等，也可以理解为sql update查询内set后面的&lt;/li&gt;
  &lt;li&gt;upsert : 可选，这个参数的意思是，如果不存在update的记录，是否插入objNew,true为插入，默认是false，不插入。&lt;/li&gt;
  &lt;li&gt;multi : 可选，mongodb 默认是false,只更新找到的第一条记录，如果这个参数为true,就把按条件查出来多条记录全部更新。&lt;/li&gt;
  &lt;li&gt;writeConcern :可选，抛出异常的级别。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;删除文档&quot;&gt;删除文档&lt;/h2&gt;

&lt;p&gt;remove() 方法的基本语法格式如下所示：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;db.collection.remove(
   &amp;lt;query&amp;gt;,
   &amp;lt;justOne&amp;gt;
)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;如果你的 MongoDB 是 2.6 版本以后的，语法格式如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;db.collection.remove(
   &amp;lt;query&amp;gt;,
   {
     justOne: &amp;lt;boolean&amp;gt;,
     writeConcern: &amp;lt;document&amp;gt;
   }
)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;参数说明：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;query :（可选）删除的文档的条件。&lt;/li&gt;
  &lt;li&gt;justOne : （可选）如果设为 true 或 1，则只删除一个文档。&lt;/li&gt;
  &lt;li&gt;writeConcern :（可选）抛出异常的级别。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;另：&lt;/p&gt;

&lt;p&gt;remove() 方法已经过时了，现在官方推荐使用 deleteOne() 和 deleteMany() 方法。&lt;/p&gt;

&lt;h2 id=&quot;查询文档&quot;&gt;查询文档&lt;/h2&gt;

&lt;p&gt;MongoDB 查询数据的语法格式如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;db.collection.find(query, projection)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;query ：可选，使用查询操作符指定查询条件&lt;/li&gt;
  &lt;li&gt;projection ：可选，使用投影操作符指定返回的键。查询时返回文档中所有键值， 只需省略该参数即可（默认省略）。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如果你需要以易读的方式来读取数据，可以使用 pretty() 方法，语法格式如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;db.col.find().pretty()
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;pretty() 方法以格式化的方式来显示所有文档。&lt;/p&gt;

&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;

&lt;p&gt;以上是一些最基本的mongoDB的常用操作，若想看一些详情的文档和功能可以看官方的文档和一些教程。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;参考&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://docs.mongodb.com/?_ga=2.76410965.1778730410.1511524353-1232494664.1511524353&quot;&gt;mongoDB官方文档&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.runoob.com/mongodb/mongodb-tutorial.html&quot;&gt;mongoDB教程&lt;/a&gt;&lt;/p&gt;

</description>
        <pubDate>Sat, 21 Oct 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/mongodb/2017/10/21/mongo.html</link>
        <guid isPermaLink="true">http://localhost:4000/mongodb/2017/10/21/mongo.html</guid>
        
        <category>mongo</category>
        
        
        <category>mongoDB</category>
        
      </item>
    
      <item>
        <title>mongoose基础</title>
        <description>&lt;p&gt;在Nodejs开发中，我们一般使用mongoose来操作mongoDB数据库。下面我么来学习下mongoose常用的用法。&lt;/p&gt;

&lt;h2 id=&quot;准备工作&quot;&gt;准备工作&lt;/h2&gt;

&lt;p&gt;那要使用它，首先你得装上node.js和mongodb并启动mongodb数据库 &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;Github地址：https://github.com/Automattic/mongoose &lt;br /&gt;
API Docs：http://mongoosejs.com/docs/guide.html&lt;/p&gt;

&lt;h2 id=&quot;概念理解&quot;&gt;概念理解&lt;/h2&gt;

&lt;p&gt;要学习mongoose首先要了解三个重要的概念，他们是Schema、Model、Document。它们的关系是Schema生成Model、Model创造Document。 &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;Schema类似于定义表结构，但并不完全准确。它用于创建表时的数据定义(不仅仅可以定义文档的结构和属性，还可以定义文档的实例方法、静态模型方法、复合索引等)，每个Schema会映射到mongodb中的一个collection。Schema不具备操作数据库的能力，主要用于定义结构。 &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;Model是由Schema编译而成的构造器，具有抽象属性和行为，可以对数据库进行增删查改。Model所能增删查改的具体值是由Schema定义的，Schema定义以外的值则没有效果。在mongoDB中一个数据库有多个collections（由Schema定义结构），而每个collections有多个document（类似js对象一般的键值对）。&lt;/p&gt;

&lt;p&gt;Model的每一个实例（instance）就是一个文档document。Document是由Model创建的实体，它的操作也会影响数据库。&lt;/p&gt;

&lt;h2 id=&quot;连接数据库&quot;&gt;连接数据库&lt;/h2&gt;

&lt;p&gt;在使用前首先连接数据库（若没有则创建之）&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var mongoose = require('mongoose');

mongoose.connect('mongodb://localhost:27017/test'); 
//已连接
mongoose.connection.on('connected', function () {    
    console.log('已连接');  
});    
//连接错误
mongoose.connection.on('error',function (err) {    
    console.log('出错');  
});    
//断开连接
mongoose.connection.on('disconnected', function () {    
    console.log('断开连接');  
});    
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;其它事件可以自行查看：http://mongoosejs.com/docs/api.html#connection_Connection&lt;/p&gt;

&lt;h2 id=&quot;定义schema&quot;&gt;定义Schema&lt;/h2&gt;

&lt;p&gt;Schema是mongoose中需要事先定义的数据模式，类似于表结构，不过mongoDB中不叫表，叫collections。&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;模型可以看作mysql中的数据表，属性可以看作是字段，当然这个类比并不十分正确。&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;每个Schema对应当前连接的数据库的一个collection,若不存在则会自动创建。 &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;Schema不具备操作数据库的能力。 &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;下面我们来看下如何创建Schema&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var mongoose = require('mongoose');
Schema = mongoose.Schema;

var blogSchema = new Schema({
  title:  String,
  author: String,
  body:   String,
  comments: [{ body: String, date: Date }],
  date: { type: Date, default: Date.now },
  hidden: Boolean,
  meta: {
    votes: Number,
    favs:  Number
  }
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;type有下面这些，&lt;code class=&quot;highlighter-rouge&quot;&gt;String&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;Number&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;Boolean &lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;Array&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;Buffer&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;Date&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;ObjectId&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;Mixed&lt;/code&gt;类型&lt;/p&gt;

&lt;h2 id=&quot;生成model&quot;&gt;生成Model&lt;/h2&gt;

&lt;p&gt;模型Model是根据Schema编译出的构造器，或者称为类，通过Model可以实例化出文档对象document。 &lt;br /&gt;
下面根据Schema构建一个Model&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var Blog = mongoose.model('Blog', blogSchema);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;Model实例化之后为document。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var blogInstance = new Blog({
  ...
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;常用数据库操作&quot;&gt;常用数据库操作&lt;/h2&gt;

&lt;h3 id=&quot;新增&quot;&gt;新增&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;document.save()&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;model实例化后的document可用save新增文档&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//实例化model
var blogInstance = new Blog({
  ...
});
//调用save方法即插入一个新的document
user.save(function (err, res) {
    if (err) {
        console.log(&quot;Error:&quot; + err);
    }
    else {
        console.log(&quot;Res:&quot; + res);
    }
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;model.create()&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;使用save()方法，需要先实例化为文档，再使用save()方法保存文档。而create()方法，则直接在模型Model上操作，并且可以同时新增多个文档&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Blog.create({name:&quot;xiaowang&quot;},{name:&quot;xiaoli&quot;},function(err,doc1,doc2){
  console.log(doc1);
  console.log(doc2);
});  
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;h3 id=&quot;查询&quot;&gt;查询&lt;/h3&gt;

&lt;p&gt;查询文档有以下三种方法&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;find()
findById()
findOne()
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;find()&lt;/strong&gt;
第一个参数表示查询条件，第二个参数用于控制返回的字段，第三个参数用于配置查询参数，第四个参数是回调函数，回调函数的形式为function(err,docs){}&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Model.find(conditions, [projection], [options], [callback])
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;findById()&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Model.findById(id, [projection], [options], [callback])
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;findOne()&lt;/strong&gt;
该方法返回查找到的所有实例的第一个&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Model.findOne([conditions], [projection], [options], [callback])
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;h3 id=&quot;更新&quot;&gt;更新&lt;/h3&gt;
&lt;p&gt;更新文档有以下两种方法&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;update()
updateMany()
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;update()&lt;/strong&gt;
第一个参数conditions为查询条件，第二个参数doc为需要修改的数据，第三个参数options为控制选项，第四个参数是回调函数&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Model.update(conditions, doc, [options], [callback])
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;updateMany()&lt;/strong&gt;
updateMany()与update()方法唯一的区别就是默认更新多个文档，即使设置{multi:false}也无法只更新第一个文档&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Model.updateMany(conditions, doc, [options], [callback])
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;删除&quot;&gt;删除&lt;/h3&gt;
&lt;p&gt;更新文档有以下三种方法&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;remove()
findOneAndRemove()
findByIdAndRemove()
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;remove()&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;remove有两种形式，一种是文档的remove()方法，一种是Model的remove()方法。&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;下面介绍Model的remove()方法，该方法的第一个参数conditions为查询条件，第二个参数回调函数的形式如下function(err){}。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;model.remove(conditions, [callback])
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;下面介绍文档的remove()方法，该方法的参数回调函数的形式如下function(err,doc){}&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;document.remove([callback])
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;findOneAndRemove()&lt;/strong&gt;
model的remove()会删除符合条件的所有数据，如果只删除符合条件的第一条数据，则可以使用model的findOneAndRemove()方法&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Model.findOneAndRemove(conditions, [options], [callback])
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;findByIdAndRemove()&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Model.findByIdAndRemove(id, [options], [callback])
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;前后钩子&quot;&gt;前后钩子&lt;/h3&gt;
&lt;p&gt;前后钩子即pre()和post()方法，又称为中间件，是在执行某些操作时可以执行的函数。中间件在schema上指定，类似于静态方法或实例方法等&lt;/p&gt;

&lt;p&gt;可以在数据库执行下列操作时，设置前后钩子&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;init
validate
save
remove
count
find
findOne
findOneAndRemove
findOneAndUpdate
insertMany
update
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;pre()&lt;/strong&gt;
以find()方法为例，在执行find()方法之前，执行pre()方法&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var schema = new mongoose.Schema({ age:Number, name: String,x:Number,y:Number});  
schema.pre('find',function(next){
    console.log('我是pre方法1');
    next();
});
schema.pre('find',function(next){
    console.log('我是pre方法2');
    next();
});  
var temp = mongoose.model('temp', schema);
temp.find(function(err,docs){
    console.log(docs[0]);
})    
/*
我是pre方法1
我是pre方法2
{ _id: 5972ed35e6f98ec60e3dc886,name: 'huochai',age: 27,x: 1,y: 2 }
*/
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;查询后处理&quot;&gt;查询后处理&lt;/h3&gt;

&lt;p&gt;常用的查询后处理的方法如下所示&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sort     排序
skip     跳过
limit    限制
select   显示字段
exect    执行
count    计数
distinct 去重
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;例子&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//按照age从小到大排列
temp.find().sort(&quot;age&quot;).exec(function(err,docs){
    console.log(docs);
}); 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;文档验证&quot;&gt;文档验证&lt;/h3&gt;

&lt;p&gt;如果不进行文档验证，保存文档时，就可以不按照Schema设置的字段进行设置，分为以下几种情况&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;缺少字段的文档可以保存成功&lt;/li&gt;
  &lt;li&gt;包含未设置的字段的文档也可以保存成功，未设置的字段不被保存&lt;/li&gt;
  &lt;li&gt;包含字段类型与设置不同的字段的文档也可以保存成功，不同字段类型的字段被保存为设置的字段类型&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;而通过文档验证，就可以避免以上几种情况发生 &lt;br /&gt;
文档验证在SchemaType中定义，格式如下&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;name:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;{type:String,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;validator:value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;常用验证包括以下几种&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;required: 数据必须填写
default: 默认值
validate: 自定义匹配
min: 最小值(只适用于数字)
max: 最大值(只适用于数字)
match: 正则匹配(只适用于字符串)
enum:  枚举匹配(只适用于字符串)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;参考&quot;&gt;参考&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/xiaohuochai/p/7215067.html?utm_source=itdadao&amp;amp;utm_medium=referral&quot;&gt;Mongoose基础入门&lt;/a&gt; &lt;br /&gt;
&lt;a href=&quot;http://www.cnblogs.com/zhongweiv/p/mongoose.html&quot;&gt;Mongoose介绍和入门&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Fri, 20 Oct 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/mongodb/2017/10/20/mongoose.html</link>
        <guid isPermaLink="true">http://localhost:4000/mongodb/2017/10/20/mongoose.html</guid>
        
        <category>mongoose</category>
        
        
        <category>mongoDB</category>
        
      </item>
    
      <item>
        <title>HTTP与TCP/IP网络协议基础知识与重点</title>
        <description>&lt;h2 id=&quot;参考&quot;&gt;参考&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;http://www.jianshu.com/p/6e9e4156ece3&quot;&gt;一篇文章带你详解 HTTP 协议&lt;/a&gt; &lt;br /&gt;
&lt;a href=&quot;http://www.jianshu.com/p/9f3e879a4c9c&quot;&gt;一篇文章带你熟悉 TCP/IP 协议&lt;/a&gt; &lt;br /&gt;
&lt;a href=&quot;https://book.douban.com/subject/25863515/&quot;&gt;图解HTTP&lt;/a&gt; &lt;br /&gt;
&lt;a href=&quot;https://book.douban.com/subject/24737674/&quot;&gt;图解TCP/IP&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;http协议重点&quot;&gt;HTTP协议重点&lt;/h2&gt;
&lt;h3 id=&quot;1常用的http方法&quot;&gt;1.常用的HTTP方法&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;GET&lt;/strong&gt;： 用于请求访问已经被URI（统一资源标识符）识别的资源，可以通过URL传参给服务器。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;POST&lt;/strong&gt;：用于传输信息给服务器，主要功能与GET方法类似，但一般推荐使用POST方式。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;PUT&lt;/strong&gt;： 传输文件，报文主体中包含文件内容，保存到对应URI位置。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;HEAD&lt;/strong&gt;： 获得报文首部，与GET方法类似，只是不返回报文主体，一般用于验证URI是否有效。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;DELETE&lt;/strong&gt;：删除文件，与PUT方法相反，删除对应URI位置的文件。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;OPTIONS&lt;/strong&gt;：查询相应URI支持的HTTP方法。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;2get方法与post方法的区别&quot;&gt;2.GET方法与POST方法的区别&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;区别一：&lt;br /&gt;
get重点在从服务器上获取资源，post重点在向服务器发送数据；&lt;/li&gt;
  &lt;li&gt;区别二：&lt;br /&gt;
get传输数据是通过URL请求，以field（字段）= value的形式，置于URL后，并用”?”连接，多个请求数据间用”&amp;amp;”连接，如http://127.0.0.1/Test/login.action?name=admin&amp;amp;password=admin，这个过程用户是可见的；&lt;br /&gt;
post传输数据通过Http的post机制，将字段与对应值封存在请求实体中发送给服务器，这个过程对用户是不可见的；&lt;/li&gt;
  &lt;li&gt;区别三：&lt;br /&gt;
Get传输的数据量小，因为受URL长度限制，但效率较高；&lt;br /&gt;
Post可以传输大量数据，所以上传文件时只能用Post方式；&lt;/li&gt;
  &lt;li&gt;区别四：&lt;br /&gt;
get是不安全的，因为URL是可见的，可能会泄露私密信息，如密码等；&lt;br /&gt;
post较get安全性较高；&lt;/li&gt;
  &lt;li&gt;区别五：&lt;br /&gt;
get方式只能支持ASCII字符，向服务器传的中文字符可能会乱码。&lt;br /&gt;
post支持标准字符集，可以正确传递中文字符&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;3http请求报文与响应报文格式&quot;&gt;3.HTTP请求报文与响应报文格式&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;请求报文包含三部分：
    &lt;ol&gt;
      &lt;li&gt;请求行：包含请求方法、URI、HTTP版本信息&lt;/li&gt;
      &lt;li&gt;请求首部字段&lt;/li&gt;
      &lt;li&gt;请求内容实体&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;响应报文包含三部分：
    &lt;ol&gt;
      &lt;li&gt;状态行：包含HTTP版本、状态码、状态码的原因短语&lt;/li&gt;
      &lt;li&gt;响应首部字段&lt;/li&gt;
      &lt;li&gt;响应内容实体&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;4常见的http相应状态码&quot;&gt;4.常见的HTTP相应状态码&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;返回的状态&lt;br /&gt;
&lt;strong&gt;1xx&lt;/strong&gt;：指示信息–表示请求已接收，继续处理&lt;br /&gt;
&lt;strong&gt;2xx&lt;/strong&gt;：成功–表示请求已被成功接收、理解、接受&lt;br /&gt;
&lt;strong&gt;3xx&lt;/strong&gt;：重定向–要完成请求必须进行更进一步的操作&lt;br /&gt;
&lt;strong&gt;4xx&lt;/strong&gt;：客户端错误–请求有语法错误或请求无法实现&lt;br /&gt;
&lt;strong&gt;5xx&lt;/strong&gt;：服务器端错误–服务器未能实现合法的请求&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;常见状态码&lt;br /&gt;
&lt;strong&gt;200&lt;/strong&gt;：请求被正常处理&lt;br /&gt;
&lt;strong&gt;204&lt;/strong&gt;：请求被受理但没有资源可以返回&lt;br /&gt;
&lt;strong&gt;206&lt;/strong&gt;：客户端只是请求资源的一部分，服务器只对请求的部分资源执行GET方法，相应报文中通过Content-Range指定范围的资源。&lt;br /&gt;
&lt;strong&gt;301&lt;/strong&gt;：永久性重定向&lt;br /&gt;
&lt;strong&gt;302&lt;/strong&gt;：临时重定向&lt;br /&gt;
&lt;strong&gt;303&lt;/strong&gt;：与302状态码有相似功能，只是它希望客户端在请求一个URI的时候，能通过GET方法重定向到另一个URI上&lt;br /&gt;
&lt;strong&gt;304&lt;/strong&gt;：发送附带条件的请求时，条件不满足时返回，与重定向无关&lt;br /&gt;
&lt;strong&gt;307&lt;/strong&gt;：临时重定向，与302类似，只是强制要求使用POST方法&lt;br /&gt;
&lt;strong&gt;400&lt;/strong&gt;：请求报文语法有误，服务器无法识别&lt;br /&gt;
&lt;strong&gt;401&lt;/strong&gt;：请求需要认证&lt;br /&gt;
&lt;strong&gt;403&lt;/strong&gt;：请求的对应资源禁止被访问&lt;br /&gt;
&lt;strong&gt;404&lt;/strong&gt;：服务器无法找到对应资源&lt;br /&gt;
&lt;strong&gt;500&lt;/strong&gt;：服务器内部错误&lt;br /&gt;
&lt;strong&gt;503&lt;/strong&gt;：服务器正忙&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;tcpip协议重点&quot;&gt;TCP/IP协议重点&lt;/h2&gt;

&lt;h3 id=&quot;1计算机网络体系结构分层&quot;&gt;1.计算机网络体系结构分层&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;/img/postsImg/http/pic1.png&quot; alt=&quot;分层模型&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;2数据处理流程&quot;&gt;2.数据处理流程&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/img/postsImg/http/pic2.png&quot; alt=&quot;数据处理流程&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;3tcp连接建立释放时的握手过程&quot;&gt;3.TCP连接建立、释放时的握手过程　　&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;三次握手&lt;/strong&gt; &lt;br /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;TCP 提供面向有连接的通信传输。面向有连接是指在数据通信开始之前先做好两端之间的准备工作。&lt;/li&gt;
  &lt;li&gt;所谓三次握手是指建立一个 TCP 连接时需要客户端和服务器端总共发送三个包以确认连接的建立。在socket编程中，这一过程由客户端执行connect来触发。
&lt;br /&gt;
下面来看看三次握手的流程图：
&lt;img src=&quot;/img/postsImg/http/pic3.png&quot; alt=&quot;流程图&quot; /&gt;&lt;/li&gt;
  &lt;li&gt;第一次握手：客户端将标志位SYN置为1，随机产生一个值seq=J，并将该数据包发送给服务器端，客户端进入SYN_SENT状态，等待服务器端确认。&lt;/li&gt;
  &lt;li&gt;第二次握手：服务器端收到数据包后由标志位SYN=1知道客户端请求建立连接，服务器端将标志位SYN和ACK都置为1，ack=J+1，随机产生一个值seq=K，并将该数据包发送给客户端以确认连接请求，服务器端进入SYN_RCVD状态。&lt;/li&gt;
  &lt;li&gt;第三次握手：客户端收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给服务器端，服务器端检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，客户端和服务器端进入ESTABLISHED状态，完成三次握手，随后客户端与服务器端之间可以开始传输数据了。
&lt;br /&gt;
&lt;strong&gt;四次挥手&lt;/strong&gt; &lt;br /&gt;&lt;/li&gt;
  &lt;li&gt;四次挥手即终止TCP连接，就是指断开一个TCP连接时，需要客户端和服务端总共发送4个包以确认连接的断开。在socket编程中，这一过程由客户端或服务端任一方执行close来触发。&lt;/li&gt;
  &lt;li&gt;由于TCP连接是全双工的，因此，每个方向都必须要单独进行关闭，这一原则是当一方完成数据发送任务后，发送一个FIN来终止这一方向的连接，收到一个FIN只是意味着这一方向上没有数据流动了，即不会再收到数据了，但是在这个TCP连接上仍然能够发送数据，直到这一方向也发送了FIN。首先进行关闭的一方将执行主动关闭，而另一方则执行被动关闭。
&lt;br /&gt;
下面来看看四次挥手的流程图：
&lt;img src=&quot;/img/postsImg/http/pic4.png&quot; alt=&quot;流程图&quot; /&gt;&lt;/li&gt;
  &lt;li&gt;中断连接端可以是客户端，也可以是服务器端。&lt;/li&gt;
  &lt;li&gt;第一次挥手：客户端发送一个FIN=M，用来关闭客户端到服务器端的数据传送，客户端进入FIN_WAIT_1状态。意思是说”我客户端没有数据要发给你了”，但是如果你服务器端还有数据没有发送完成，则不必急着关闭连接，可以继续发送数据。&lt;/li&gt;
  &lt;li&gt;第二次挥手：服务器端收到FIN后，先发送ack=M+1，告诉客户端，你的请求我收到了，但是我还没准备好，请继续你等我的消息。这个时候客户端就进入FIN_WAIT_2 状态，继续等待服务器端的FIN报文。&lt;/li&gt;
  &lt;li&gt;第三次挥手：当服务器端确定数据已发送完成，则向客户端发送FIN=N报文，告诉客户端，好了，我这边数据发完了，准备好关闭连接了。服务器端进入LAST_ACK状态。&lt;/li&gt;
  &lt;li&gt;第四次挥手：客户端收到FIN=N报文后，就知道可以关闭连接了，但是他还是不相信网络，怕服务器端不知道要关闭，所以发送ack=N+1后进入TIME_WAIT状态，如果Server端没有收到ACK则可以重传。服务器端收到ACK后，就知道可以断开连接了。客户端等待了2MSL后依然没有收到回复，则证明服务器端已正常关闭，那好，我客户端也可以关闭连接了。最终完成了四次握手。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;

&lt;p&gt;以上的都是些网络协议方面的老生常谈的基础知识，其中内容十分不完整和全面。主要是要有一些网络方面的基础概念，遇到问题的时候懂得要到哪里去查，一些细的方面的知识可以等到实际应用中去体会。&lt;/p&gt;

</description>
        <pubDate>Wed, 11 Oct 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/net/2017/10/11/net.html</link>
        <guid isPermaLink="true">http://localhost:4000/net/2017/10/11/net.html</guid>
        
        <category>HTTP</category>
        
        <category>TCP/IP</category>
        
        
        <category>net</category>
        
      </item>
    
      <item>
        <title>[译]一个100行内的现代js路由</title>
        <description>&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;原文:http://krasimirtsonev.com/blog/article/A-modern-JavaScript-router-in-100-lines-history-api-pushState-hash-url
作者:Krasimir
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;(这个js路由现在被放项目&lt;a href=&quot;https://github.com/krasimir/navigo&quot;&gt;Navigo&lt;/a&gt;中。这里还有一篇你可能会感兴趣的文章&lt;a href=&quot;http://krasimirtsonev.com/blog/article/deep-dive-into-client-side-routing-navigo-pushstate-hash&quot;&gt;Deep dive into client-side routing&lt;/a&gt;)&lt;/p&gt;

&lt;p&gt;现今到处都是流行的单页面应用（SPA）。这样的应用需要一个坚实的路由机制。像&lt;a href=&quot;https://emberjs.com/&quot;&gt;Emberjs&lt;/a&gt;这样的框架确实是在建立在一个路由类上的。我不确定这是不是我喜欢的概念，但我确定的是&lt;a href=&quot;http://absurdjs.com/&quot;&gt;AbsurdJS&lt;/a&gt;需要一个内置的路由。并且这个路由在所有东西齐全的前提下，应该小巧、简单。那就让我们来看看这样一个模块是怎么样的。&lt;/p&gt;

&lt;h2 id=&quot;要求&quot;&gt;要求&lt;/h2&gt;

&lt;p&gt;这个路由应该符合下面几点&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;应该小于100行&lt;/li&gt;
  &lt;li&gt;支持像&lt;em&gt;http://site.com#products/list&lt;/em&gt;这样的hash类型的url&lt;/li&gt;
  &lt;li&gt;也能使用History API&lt;/li&gt;
  &lt;li&gt;提供易用的API&lt;/li&gt;
  &lt;li&gt;不会自动的运行&lt;/li&gt;
  &lt;li&gt;可选择监听改变&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;单例模式&quot;&gt;单例模式&lt;/h2&gt;

&lt;p&gt;我决定把路由做成只有一个实例。这也许是个坏决定，因为我就有个项目需要多个路由，但要知道这个不是常有的应用。如果我们使用单例模式，我们就不需要把路由从一个对象传到另一个对象并且我们也不需要创建它。我们只需要一个实例，这样我们就可以自动的创建它。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var Router = {
    routes: [],
    mode: null,
    root: '/'
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;这里有三个我们需要的属性。&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;routes-这个保存着当前已注册的路由&lt;/li&gt;
  &lt;li&gt;mode-根据我们使用的是history还是hash显示’hash’或者’history’&lt;/li&gt;
  &lt;li&gt;root-应用的根URL路径，只有当我们使用pushState的时候我们才需要&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;配置&quot;&gt;配置&lt;/h2&gt;

&lt;p&gt;我们需要一个方法来初始化路由。我们只需要传两个东西，但是最好在一个函数内做这些。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var Router = {
    routes: [],
    mode: null,
    root: '/',
    config: function(options) {
        this.mode = options &amp;amp;&amp;amp; options.mode &amp;amp;&amp;amp; options.mode == 'history' 
                    &amp;amp;&amp;amp; !!(history.pushState) ? 'history' : 'hash';
        this.root = options &amp;amp;&amp;amp; options.root ? '/' + this.clearSlashes(options.root) + '/' : '/';
        return this;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;只有当我们想要使用history模式并且支持&lt;em&gt;pushState&lt;/em&gt;的时候，mode才会等于’history’。否则我们将使用hash。root默认设置为单斜线’/’。&lt;/p&gt;

&lt;h2 id=&quot;获得当前的url&quot;&gt;获得当前的URL&lt;/h2&gt;

&lt;p&gt;这是我们的路由的重要部分，因为这将会告诉我们现在在什么地方。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;getFragment: function() {
    var fragment = '';
    if(this.mode === 'history') {
        fragment = this.clearSlashes(decodeURI(location.pathname + location.search));
        fragment = fragment.replace(/\?(.*)$/, '');
        fragment = this.root != '/' ? fragment.replace(this.root, '') : fragment;
    } else {
        var match = window.location.href.match(/#(.*)$/);
        fragment = match ? match[1] : '';
    }
    return this.clearSlashes(fragment);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在两个例子中我们都是用了全局的&lt;em&gt;window.location&lt;/em&gt;对象。在’history’模式版本中我们需要去掉URL的根部分。我们也需要去掉所有的GET请求参数，我们用如下的正则表达式搞定-&lt;code class=&quot;highlighter-rouge&quot;&gt;(/\?(.*)$/)&lt;/code&gt;。获取hash的值则更加简单点。注意&lt;em&gt;clearSlashes&lt;/em&gt;函数的作用。它的用处是去除字符串开头和结尾的斜杠。这是有必要的，因为我们不能强迫开发者使用特定格式的URL。无论他传什么都会转成同样的值。&lt;/p&gt;

&lt;h2 id=&quot;添加和修改路由&quot;&gt;添加和修改路由&lt;/h2&gt;

&lt;p&gt;当我在制作&lt;a href=&quot;http://absurdjs.com/&quot;&gt;AbsurdJS&lt;/a&gt;的时候，我总是尝试尽可能多的给开发者控制权。几乎所有的路由插件在执行路由的时候是用字符串路由。然而我更喜欢传一个正则表达式。这更加的灵活，因为有的时候我们也许会做很奇怪的匹配。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;add: function(re, handler) {
    if(typeof re == 'function') {
        handler = re;
        re = '';
    }
    this.routes.push({ re: re, handler: handler});
    return this;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;这个将&lt;em&gt;routes&lt;/em&gt;数组进行填充。如果只有一个函数传进来，那么这个函数就会被作为handler，而默认的路由就是一个空字符串。注意这里大部分的函数return this。这可以让我们链式调用方法。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;remove: function(param) {
    for(var i=0, r; i&amp;lt;this.routes.length, r = this.routes[i]; i++) {
        if(r.handler === param || r.re.toString() === param.toString()) {
            this.routes.splice(i, 1); 
            return this;
        }
    }
    return this;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;只有我们传一个正则表达式或者handler传给&lt;em&gt;add&lt;/em&gt;方法的时候，路由的删除才会调用。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;flush: function() {
    this.routes = [];
    this.mode = null;
    this.root = '/';
    return this;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;有的时候我们需要重新初始化类。那么这时候你就可以用上面的&lt;em&gt;flush&lt;/em&gt;方法。&lt;/p&gt;

&lt;h2 id=&quot;登记&quot;&gt;登记&lt;/h2&gt;

&lt;p&gt;好，现在我们已经有了增加和删除URL的API。我们也可以得到当前的地址了。下一步我们要比较已注册的入口。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;check: function(f) {
    var fragment = f || this.getFragment();
    for(var i=0; i&amp;lt;this.routes.length; i++) {
        var match = fragment.match(this.routes[i].re);
        if(match) {
            match.shift();
            this.routes[i].handler.apply({}, match);
            return this;
        }           
    }
    return this;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;我们通过传入函数作为参数或者调用&lt;em&gt;getFragment&lt;/em&gt;方法来获得&lt;em&gt;fragment&lt;/em&gt;。接下来我们执行一个单纯的循环来遍历routes来查看匹配。只有当正则表达式没有匹配到的时候，变量&lt;em&gt;match&lt;/em&gt;的值是null。否则&lt;em&gt;match&lt;/em&gt;的值会像下面这样&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[&quot;products/12/edit/22&quot;, &quot;12&quot;, &quot;22&quot;, index: 1, input: &quot;/products/12/edit/22&quot;]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;这是一个包含了匹配到的数组和所有可记录的子串的类数组。这意味着如果我们&lt;em&gt;shift&lt;/em&gt;第一个我们会获得URL动态部分的数组。举例：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Router
.add(/about/, function() {
    console.log('about');
})
.add(/products\/(.*)\/edit\/(.*)/, function() {
    console.log('products', arguments);
})
.add(function() {
    console.log('default');
})
.check('/products/12/edit/22');
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;这段脚本输出&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;products [&quot;12&quot;, &quot;22&quot;]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;到此为止我们处理了动态URL。&lt;/p&gt;

&lt;h2 id=&quot;监听变化&quot;&gt;监听变化&lt;/h2&gt;

&lt;p&gt;当然我们不能总是调用&lt;em&gt;check&lt;/em&gt;方法。我们需要当地址栏改变的时候，我们能收到通知。我所说的改变甚至意味着点击浏览器上的后退按钮。如果你用过History API的话你就会知道有一个&lt;em&gt;popstate&lt;/em&gt;事件。当URL改变的时候就会触发这个事件。然而我发现在一些浏览器中，当页面加载完的时候会分发这个事件。这个情况加上其他的一些问题让我转向了其他的解决方案。因为我希望甚至在模式被设置为hash也能进行监听，我决定采用setinterval。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;listen: function() {
    var self = this;
    var current = self.getFragment();
    var fn = function() {
        if(current !== self.getFragment()) {
            current = self.getFragment();
            self.check(current);
        }
    }
    clearInterval(this.interval);
    this.interval = setInterval(fn, 50);
    return this;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;我们需要把最近的URL存下来这样我们才能用于对比下一个。&lt;/p&gt;

&lt;h2 id=&quot;改变url&quot;&gt;改变URL&lt;/h2&gt;
&lt;p&gt;最后我们需要一个函数能改变当前的地址并触发路由handler&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;navigate: function(path) {
    path = path ? path : '';
    if(this.mode === 'history') {
        history.pushState(null, null, this.root + this.clearSlashes(path));
    } else {        
        window.location.href = window.location.href.replace(/#(.*)$/, '') + '#' + path;
    }
    return this;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;同样的，我们根据不同的模式做不同的事。如果History API可用，我们使用&lt;em&gt;pushState&lt;/em&gt;。否则我们就采用window.location。&lt;/p&gt;

&lt;h2 id=&quot;最终源码&quot;&gt;最终源码&lt;/h2&gt;

&lt;p&gt;以下是最终源码加一点例子&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var Router = {
    routes: [],
    mode: null,
    root: '/',
    config: function(options) {
        this.mode = options &amp;amp;&amp;amp; options.mode &amp;amp;&amp;amp; options.mode == 'history' 
                    &amp;amp;&amp;amp; !!(history.pushState) ? 'history' : 'hash';
        this.root = options &amp;amp;&amp;amp; options.root ? '/' + this.clearSlashes(options.root) + '/' : '/';
        return this;
    },
    getFragment: function() {
        var fragment = '';
        if(this.mode === 'history') {
            fragment = this.clearSlashes(decodeURI(location.pathname + location.search));
            fragment = fragment.replace(/\?(.*)$/, '');
            fragment = this.root != '/' ? fragment.replace(this.root, '') : fragment;
        } else {
            var match = window.location.href.match(/#(.*)$/);
            fragment = match ? match[1] : '';
        }
        return this.clearSlashes(fragment);
    },
    clearSlashes: function(path) {
        return path.toString().replace(/\/$/, '').replace(/^\//, '');
    },
    add: function(re, handler) {
        if(typeof re == 'function') {
            handler = re;
            re = '';
        }
        this.routes.push({ re: re, handler: handler});
        return this;
    },
    remove: function(param) {
        for(var i=0, r; i&amp;lt;this.routes.length, r = this.routes[i]; i++) {
            if(r.handler === param || r.re.toString() === param.toString()) {
                this.routes.splice(i, 1); 
                return this;
            }
        }
        return this;
    },
    flush: function() {
        this.routes = [];
        this.mode = null;
        this.root = '/';
        return this;
    },
    check: function(f) {
        var fragment = f || this.getFragment();
        for(var i=0; i&amp;lt;this.routes.length; i++) {
            var match = fragment.match(this.routes[i].re);
            if(match) {
                match.shift();
                this.routes[i].handler.apply({}, match);
                return this;
            }           
        }
        return this;
    },
    listen: function() {
        var self = this;
        var current = self.getFragment();
        var fn = function() {
            if(current !== self.getFragment()) {
                current = self.getFragment();
                self.check(current);
            }
        }
        clearInterval(this.interval);
        this.interval = setInterval(fn, 50);
        return this;
    },
    navigate: function(path) {
        path = path ? path : '';
        if(this.mode === 'history') {
            history.pushState(null, null, this.root + this.clearSlashes(path));
        } else {
            window.location.href = window.location.href.replace(/#(.*)$/, '') + '#' + path;
        }
        return this;
    }
}

// configuration
Router.config({ mode: 'history'});

// returning the user to the initial state
Router.navigate();

// adding routes
Router
.add(/about/, function() {
    console.log('about');
})
.add(/products\/(.*)\/edit\/(.*)/, function() {
    console.log('products', arguments);
})
.add(function() {
    console.log('default');
})
.check('/products/12/edit/22').listen();

// forwarding
Router.navigate('/about');
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;

&lt;p&gt;这个路由大概90行。支持hash类型的URL和新的history API。如果你不想仅仅想使用路由这个功能而使用整个框架，这个就对你是有帮助的。&lt;/p&gt;

&lt;p&gt;这个类是&lt;a href=&quot;http://absurdjs.com/&quot;&gt;AbsurdJS&lt;/a&gt;的一部分。在&lt;a href=&quot;http://absurdjs.com/pages/api/build-in-components/#router&quot;&gt;这里&lt;/a&gt;可以查看文档。&lt;/p&gt;
</description>
        <pubDate>Tue, 10 Oct 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/js/2017/10/10/routes-in-100-line.html</link>
        <guid isPermaLink="true">http://localhost:4000/js/2017/10/10/routes-in-100-line.html</guid>
        
        <category>routes</category>
        
        <category>路由</category>
        
        
        <category>js</category>
        
      </item>
    
      <item>
        <title>入门正则表达式</title>
        <description>&lt;h2 id=&quot;资料&quot;&gt;资料&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;http://deerchao.net/tutorials/regex/regex.htm&quot;&gt;正则表达式30分钟入门教程&lt;/a&gt;
&lt;a href=&quot;https://juejin.im/post/582455e467f3560058c6641e&quot;&gt;《JavaScript 闯关记》之正则表达式&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;正则表达式是什么&quot;&gt;正则表达式是什么&lt;/h2&gt;

&lt;p&gt;在编写处理字符串的程序或网页时，经常会有查找符合某些复杂规则的字符串的需要。正则表达式就是用于描述这些规则的工具。换句话说，正则表达式就是记录文本规则的代码。&lt;/p&gt;

&lt;h2 id=&quot;为什么要用正则表达式&quot;&gt;为什么要用正则表达式&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;密码、账号等验证。&lt;/li&gt;
  &lt;li&gt;看源码需要，写框架，后端编程，路由都离不开正则&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;元字符&quot;&gt;元字符&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;http://www.runoob.com/regexp/regexp-metachar.html&quot;&gt;常用的正则表达式元字符&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;例子加深理解&quot;&gt;例子加深理解&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;例子一 &lt;br /&gt;
    &lt;ul&gt;
      &lt;li&gt;正则表达式:&lt;code class=&quot;highlighter-rouge&quot;&gt;\bhi\b.*\bLucy\b&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;含义:先是一个单词hi,然后是任意个任意字符(但不能是换行)，最后是Lucy这个单词&lt;/li&gt;
      &lt;li&gt;知识点:&lt;/li&gt;
    &lt;/ul&gt;
    &lt;ol&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;\b&lt;/code&gt;:代表着&lt;em&gt;单词的开头或结尾，也就是单词的分界处&lt;/em&gt;&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;.&lt;/code&gt;:匹配&lt;em&gt;除了换行符以外的任意字符&lt;/em&gt;&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;*&lt;/code&gt;:它指定&lt;em&gt;前边的内容可以连续重复使用任意次以使整个表达式得到匹配&lt;/em&gt;&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;例子二
    &lt;ul&gt;
      &lt;li&gt;正则表达式:&lt;code class=&quot;highlighter-rouge&quot;&gt;0\d\d-\d\d\d\d\d\d\d\d&lt;/code&gt; 或 &lt;code class=&quot;highlighter-rouge&quot;&gt;0\d{2}-\d{8}&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;含义:以0开头，然后是两个数字，然后是一个连字号“-”，最后是8个数字&lt;/li&gt;
      &lt;li&gt;知识点:&lt;/li&gt;
    &lt;/ul&gt;
    &lt;ol&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;\d&lt;/code&gt;:匹配&lt;em&gt;一位数字&lt;/em&gt;&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;:匹配&lt;em&gt;必须连续重复匹配2次&lt;/em&gt;&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;例子三
    &lt;ul&gt;
      &lt;li&gt;正则表达式:&lt;code class=&quot;highlighter-rouge&quot;&gt;\ba\w*\b&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;含义:a开头的单词——先是某个单词开始处(\b)，然后是字母a,然后是任意数量的字母或数字(\w*)，最后是单词结束处(\b)&lt;/li&gt;
      &lt;li&gt;知识点:&lt;/li&gt;
    &lt;/ul&gt;
    &lt;ol&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;\w&lt;/code&gt;:匹配&lt;em&gt;字母或数字或下划线或汉字等&lt;/em&gt;&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;\s&lt;/code&gt;:匹配&lt;em&gt;任意的空白符，包括空格，制表符(Tab)，换行符，中文全角空格等&lt;/em&gt;（虽然这里没有）&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;还有一些元字符&quot;&gt;还有一些元字符&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;^&lt;/code&gt;:匹配&lt;em&gt;匹配字符串的开始&lt;/em&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;$&lt;/code&gt;:匹配&lt;em&gt;匹配字符串的结束&lt;/em&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;n,m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;:重复的次数不能少于n次，不能多于m次&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;\&lt;/code&gt;:标记为一个元字符、或一个原义字符、或一个 向后引用、或一个八进制转义符&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;重复：&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th&gt;代码/语法&lt;/th&gt;
          &lt;th&gt;说明&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td&gt;*&lt;/td&gt;
          &lt;td&gt;重复零次或更多次&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;+&lt;/td&gt;
          &lt;td&gt;重复一次或更多次&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;?&lt;/td&gt;
          &lt;td&gt;重复零次或一次&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;{n}&lt;/td&gt;
          &lt;td&gt;重复n次&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;{n,}&lt;/td&gt;
          &lt;td&gt;重复n次或更多次&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;{n,m}&lt;/td&gt;
          &lt;td&gt;重复n到m次&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;字符类&lt;/p&gt;

    &lt;p&gt;匹配没有预定义元字符的字符集合 : 只需要在方括号里列出它们就行了 &lt;br /&gt;
 如：&lt;code class=&quot;highlighter-rouge&quot;&gt;[aeiou]&lt;/code&gt;就匹配任何一个英文元音字母&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;一些稍微高级的话题&quot;&gt;一些稍微高级的话题&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;分枝条件：&lt;code class=&quot;highlighter-rouge&quot;&gt;|&lt;/code&gt;类似于编程中的&lt;em&gt;或&lt;/em&gt;，指的是有几种规则，如果满足其中任意一种规则都应该当成匹配&lt;/li&gt;
  &lt;li&gt;分组：用小括号来指定&lt;em&gt;子表达式&lt;/em&gt;&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;反义：&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th&gt;代码/语法&lt;/th&gt;
          &lt;th&gt;说明&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td&gt;\W&lt;/td&gt;
          &lt;td&gt;匹配任意不是字母，数字，下划线，汉字的字符&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;\S&lt;/td&gt;
          &lt;td&gt;匹配任意不是空白符的字符&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;\D&lt;/td&gt;
          &lt;td&gt;匹配任意非数字的字符&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;\B&lt;/td&gt;
          &lt;td&gt;匹配不是单词开头或结束的位置&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;[^x]&lt;/td&gt;
          &lt;td&gt;匹配除了x以外的任意字符&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;[^aeiou]&lt;/td&gt;
          &lt;td&gt;匹配除了aeiou这几个字母以外的任意字符&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/li&gt;
  &lt;li&gt;后向引用：使用小括号指定一个子表达式后，匹配这个子表达式的文本(也就是此分组捕获的内容)可以在表达式或其它程序中作进一步的处理。默认情况下，每个分组会自动拥有一个组号。&lt;br /&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;后向引用&lt;/code&gt;用于重复搜索前面某个分组匹配的文本。例如，&lt;code class=&quot;highlighter-rouge&quot;&gt;\1&lt;/code&gt;代表分组1匹配的文本。&lt;/li&gt;
  &lt;li&gt;零宽断言：查找在某些内容(但并不包括这些内容)之前或之后的东西。&lt;br /&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;(?=exp)&lt;/code&gt;也叫&lt;code class=&quot;highlighter-rouge&quot;&gt;零宽度正预测先行断言&lt;/code&gt;，它断言自身出现的位置的后面能匹配表达式exp。比如&lt;code class=&quot;highlighter-rouge&quot;&gt;\b\w+(?=ing\b)&lt;/code&gt;，匹配以ing结尾的单词的前面部分(除了ing以外的部分)，如查找I’m singing while you’re dancing.时，它会匹配&lt;code class=&quot;highlighter-rouge&quot;&gt;sing&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;danc&lt;/code&gt;。&lt;/li&gt;
  &lt;li&gt;负向零宽断言：确保某个字符没有出现，但并不想去匹配它&lt;/li&gt;
  &lt;li&gt;贪婪与懒惰：当正则表达式中包含能接受重复的限定符时，通常的行为是（在使整个表达式能得到匹配的前提下）&lt;code class=&quot;highlighter-rouge&quot;&gt;匹配尽可能多的字符&lt;/code&gt;。有时，我们更需要懒惰匹配，也就是匹配尽可能少的字符。前面给出的限定符都可以被转化为懒惰匹配模式，只要在它后面加上一个问号&lt;code class=&quot;highlighter-rouge&quot;&gt;?&lt;/code&gt;。&lt;/li&gt;
  &lt;li&gt;平衡组/递归匹配&lt;/li&gt;
&lt;/ol&gt;

</description>
        <pubDate>Thu, 10 Aug 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/%E5%9F%BA%E7%A1%80/2017/08/10/regex.html</link>
        <guid isPermaLink="true">http://localhost:4000/%E5%9F%BA%E7%A1%80/2017/08/10/regex.html</guid>
        
        <category>regex</category>
        
        
        <category>基础</category>
        
      </item>
    
      <item>
        <title>[译]在10分钟内解释JavaScript Async/Await</title>
        <description>&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;原文:https://tutorialzine.com/2017/07/javascript-async-await-explained
作者:Danny Markov
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;在很长的一段时间里，JavaScript开发者不得不依靠回调函数去处理异步代码。结果，我们大部分都经历过回调地狱和遇到&lt;a href=&quot;https://tutorialzine.com/media/2017/07/callback-hell.jpg&quot;&gt;这样&lt;/a&gt;功能的恐怖。&lt;/p&gt;

&lt;p&gt;幸运的是，接下来（或者我们应该说 .then()）我们迎来了Promises. 他们提供了一个更组织化的回调方式，大多数社区迅速的转而使用它。&lt;/p&gt;

&lt;p&gt;现在，随着最新版本的Async/Await出现，写JavaScript代码更爽了。&lt;/p&gt;

&lt;h2 id=&quot;什么是asyncawait&quot;&gt;什么是Async/Await？&lt;/h2&gt;

&lt;p&gt;Async/Await是一个很久就令人期待的JavaScript功能，它让使用异步函数更加愉快和容易理解。它是基于Promises的并且和现存的所有基于Promises的API相兼容。&lt;/p&gt;

&lt;p&gt;从async和await这两个名字来的这两个关键字将会帮助我们整理我们的异步代码。&lt;/p&gt;

&lt;p&gt;Async - 声明一个异步函数（async function someName(){…}）。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;自动将一个常规函数转化为一个Promise。&lt;/li&gt;
  &lt;li&gt;当调用async函数的时候，它用函数内返回的任何值来解决（resolve）。&lt;/li&gt;
  &lt;li&gt;异步函数可以使用await&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Await-暂停执行async函数（var result = await someAsyncCall();）。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;当放在一个Promise前面执行，await强制剩下的代码等待直到那个Promise结束并且返回一个结果&lt;/li&gt;
  &lt;li&gt;Await只有和Promise一起使用才有用，和回调函数（普通函数）一起使用不会产生作用&lt;/li&gt;
  &lt;li&gt;Await只可以在async函数内部使用&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这里有一个简单的例子，希望能帮你把事情理清楚：&lt;/p&gt;

&lt;p&gt;假设我们想从我们的服务器中得到一些JSON文件。我们将写一个函数用axios库发送一个http GET 请求到https://tutorialzine.com/misc/files/example.json。 我们不得不等待服务器响应，所以很自然这个HTTP 请求是异步的。&lt;/p&gt;

&lt;p&gt;下面我们可以看到相同的功能实现了两次。首先是用Promises，然后第二次用Async / Await。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// Promise 实现方式
function getJSON(){

    // 为了让函数阻塞我们手动创建了一个Promise
    return new Promise( function(resolve) {
        axios.get('https://tutorialzine.com/misc/files/example.json')
            .then( function(json) {
                // 从请求来的数据可以从.then中得到
                // 我们使用resolve返回结果
                resolve(json);
            });
    });

}

// Async/Await 实现方式
// async关键字将会自动创建一个新的Promise并返回。
async function getJSONAsync(){
    // await关键词使我们免于写一个.then()
    let json = await axios.get('https://tutorialzine.com/misc/files/example.json');
    // GET请求的结果可以从json变量中得到
    // 我们把结果就像一个普通的同步函数一样返回
    return json;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;很明显Async/Await版本的代码更短并且可读性更强。除了使用的语法，两个函数完全相同-他们都返回Promises并且都从axios得到JSON返回。我们可以像这样调用我们的async函数：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;getJSONAsync().then( function(result) {
    // Do something with result.
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;那么asyncawait-让-promises-过时了吗&quot;&gt;那么，Async/Await 让 Promises 过时了吗？&lt;/h2&gt;

&lt;p&gt;一点也不，当我们使用Async/Await其实底层还是在使用Promises。对Promises的良好理解在长远考虑下是对你是十分有帮助的并且也是高度推荐的。&lt;/p&gt;

&lt;p&gt;这里甚至有一些情况Async/Await不能解决而我们不得不重新去寻求Promises的帮助。一种这样的场景是我们需要去调用多个独立的异步函数并等待他们所有完成。&lt;/p&gt;

&lt;p&gt;假如我们尝试用async and await，以下就会发生:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;async function getABC() {
    let A = await getValueA(); // getValueA takes 2 second to finish
    let B = await getValueB(); // getValueB takes 4 second to finish
    let C = await getValueC(); // getValueC takes 3 second to finish
    return A*B*C;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;每一个await将会等待前一个返回一个结果。因为我们一次只执行一个调用那么整个函数从开始到结束将会花9秒的时间（2+4+3）。&lt;/p&gt;

&lt;p&gt;这不是一个最佳的解决方案，因为A,B和C互相并不依赖。换句话来说我们在得到B的时候我们并不需要A的值。我们可以同时得到这些值以减去几秒钟的等待时间。&lt;/p&gt;

&lt;p&gt;同时发送所有的requests我们需要Promise.all()。这将会保证我们在进行下一步的时候我们可以得到所有的结果，但是所有的异步函数将会平行的运行，而不是一个接一个。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;async function getABC() {
  // Promise.all() allows us to send all requests at the same time. 
  let results = await Promise.all([ getValueA, getValueB, getValueC ]); 

  return results.reduce((total,value) =&amp;gt; total * value);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这种方式函数将会花费少的多的时间，在getValueB结束的时候getValueA和getValueC就已经结束了。我们将有效的减少执行的时间到最慢的请求而不是时间的总和。&lt;/p&gt;

&lt;h2 id=&quot;处理asyncawait的错误&quot;&gt;处理Async/Await的错误&lt;/h2&gt;

&lt;p&gt;另一个关于Async/Await很棒的事是它允许我们用很棒的老式try/catch块去catch任何意外的错误。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;async function doSomethingAsync(){
    try {
        // This async call may fail.
        let result = await someAsyncCall();
    }
    catch(error) {
        // If it does we will catch the error here.
    }  
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;任何我们写在try块中的等待的异步调用或者其他任何错误代码，catch都能解决他们引起的错误（error）。&lt;/p&gt;

&lt;p&gt;如果情况需要，我们也可以在执行async函数的时候抓取错误。由于所有异步函数返回Promises，所以我们可以在调用它们时简单地包含.catch()事件处理程序。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 不包含try/catch块的async函数
async function doSomethingAsync(){
    // 这个async调用也许会失败
    let result = await someAsyncCall();
    return result;  
}

// 我们catch错误在调用async函数的时候
doSomethingAsync().
    .then(successHandler)
    .catch(errorHandler);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;重要的是选择一种你喜欢的错误处理的方式，并坚持使用它。同时使用try/catch和.catch(）将很有可能导致一些问题。&lt;/p&gt;

&lt;h2 id=&quot;浏览器支持&quot;&gt;浏览器支持&lt;/h2&gt;

&lt;p&gt;Async/Await已经支持大部分的主流浏览器。绝大多数的厂商将会识别你的async/await代码而不需要额外的库-除了IE11.&lt;/p&gt;

&lt;p&gt;Node开发者只要node8或以上就可以享受到改进的异步流。它在今年晚些时候应该会变成LTS（ Long Term Support ）版本。&lt;/p&gt;

&lt;p&gt;如果这兼容性不能满足你，也有许多像Babel和TypeScript和Nodejs库asyncawait这样的JS transpiler（源码转换器）提供他们自己的跨平台版本的功能。&lt;/p&gt;

&lt;h2 id=&quot;结论&quot;&gt;结论&lt;/h2&gt;

&lt;p&gt;随着Async/Await ，JavaScript语言在代码可读性和易用性上向前迈进了一大步。能够编写类似于常规同步功能的异步代码将会受到JavaScript初学者和经验丰富的编程人员的赞赏。&lt;/p&gt;

</description>
        <pubDate>Sat, 15 Jul 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/js/2017/07/15/AsyncAwaitTran.html</link>
        <guid isPermaLink="true">http://localhost:4000/js/2017/07/15/AsyncAwaitTran.html</guid>
        
        <category>Async</category>
        
        <category>Await</category>
        
        <category>ES6</category>
        
        
        <category>JS</category>
        
      </item>
    
      <item>
        <title>理解JS的this关键字</title>
        <description>&lt;h2 id=&quot;this是什么&quot;&gt;this是什么&lt;/h2&gt;

&lt;p&gt;this是JavaScript中一个关键字，this提供了一种优雅的方式来隐式传递一个对象引用，因此可以把API设计得更加简洁并且易于复用。&lt;br /&gt;
但是，在平常使用中经常会对this产生一些误解，比较常见的会认为this“指向自身”或者“指向函数的作用域”&lt;/p&gt;

&lt;h3 id=&quot;指向自身&quot;&gt;指向自身&lt;/h3&gt;
&lt;p&gt;对于这个误解可以看下以下代码&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function foo(){
    this.a = 1;
}
foo.a = 0;
foo();
console.log(foo.a);//0
console.log(this.a);//1
console.log(window.a);//1
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;通过以上代码可以看到，this并不指向foo而是指向了window，可见this指向自身并不成立&lt;/p&gt;
&lt;h3 id=&quot;指向函数的作用域&quot;&gt;指向函数的作用域&lt;/h3&gt;
&lt;p&gt;这也是个常见的误解,请看一下代码&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function foo(){
    var a = 1;
    bar();
}
function bar(){
    console.log( this.a );
}
foo();//undefined
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;这段代码，希望利用this向上查找到a，代替作用域的效果，但并没有成功。&lt;/p&gt;
&lt;h3 id=&quot;this究竟是什么&quot;&gt;this究竟是什么&lt;/h3&gt;
&lt;p&gt;通过以上一些例子，我们可以看到，this的指向飘忽不定,在不同的场景下，this会化身不同的对象。如果不了解this的机制就很难猜到this的指向。&lt;br /&gt;
那么this究竟是什么？&lt;br /&gt;
&lt;strong&gt;&lt;em&gt;先上结论：实际上，this是在运行的时候进行绑定的，并不是在编写时绑定，它指向什么完全取决于函数在哪里被调用。&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;this绑定规则&quot;&gt;this绑定规则&lt;/h2&gt;
&lt;p&gt;要确定this的值，首先要看函数的调用位置。找到调用位置后，需要判断应用下面四条规则的哪一条&lt;/p&gt;
&lt;h3 id=&quot;默认绑定&quot;&gt;默认绑定&lt;/h3&gt;
&lt;p&gt;这条规则是无法应用其他规则时的默认规则,请看以下代码&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function foo(){
    console.log( this.a );
}
var a = 2;
foo();//2
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;在这里，foo()是直接进行调用，因此只能使用默认绑定，this指向全局对象。&lt;/p&gt;
&lt;h3 id=&quot;隐式绑定&quot;&gt;隐式绑定&lt;/h3&gt;
&lt;p&gt;这种情况是函数是被某个上下文对象调用的，比如下面的代码&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var o = {
    a:3,
    foo:function(){
        console.log(this.a);
    }
}
o.foo();
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;h4 id=&quot;隐式丢失&quot;&gt;隐式丢失&lt;/h4&gt;
&lt;p&gt;隐式绑定一个常见的问题是被隐式绑定的函数会丢失绑定对象，比较常见的情况如下&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function foo(){
    console.log(this.a);
}
function doFoo(fn){
    fn();
}
var obj = {
    a : 2,
    foo : foo
}
var a = &quot;global&quot;;
doFoo(obj.foo);//global
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;这里没有如预想的应用隐式绑定，而是应用了默认绑定，将this绑定到全局对象上了，这种情况在应用隐式绑定的时候经常遇到。&lt;/p&gt;
&lt;h3 id=&quot;显式绑定&quot;&gt;显式绑定&lt;/h3&gt;
&lt;p&gt;显式绑定通过call()或apply()方法，用于显式的指定this的绑定对象&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function foo(){
    console.log(this.a);
}
var obj = {
    a : 2
}
foo.call(obj);// 2
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;h4 id=&quot;硬绑定&quot;&gt;硬绑定&lt;/h4&gt;
&lt;p&gt;但是，显式绑定并没有解决我们之前提出的丢失绑定问题，但是显式绑定的一个变种可以解决这个问题&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function foo(something){
    console.log( this.a,something );
    return this.a + something;
}
function bind(fn,obj){
    return function(){
        return fn.apply(obj,arguments);
    }
}
function doFoo(fn,arg){
    fn(arg);
}
var obj = {
    a:2
};
var bar = bind(foo,obj);
doFoo(bar,3);// 2 3 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;这里，我们创建了一个bind函数用于绑定函数与上下文对象，这种模式称为&lt;em&gt;硬绑定&lt;/em&gt;。&lt;br /&gt;
ES5中提供了内置的bind方法&lt;/p&gt;
&lt;h3 id=&quot;new绑定&quot;&gt;new绑定&lt;/h3&gt;
&lt;p&gt;在JS中，对函数使用new操作符的时候，我们称此函数为构造函数，或者更准确的说，对这个函数进行了“构造调用”。&lt;br /&gt;
使用new来调用函数，会自动执行下面的操作。&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;创建一个全新的对象&lt;/li&gt;
  &lt;li&gt;这个新对象会被执行[[Prototype]]连接(新对象的_proto_指向函数的原型)&lt;/li&gt;
  &lt;li&gt;这个新对象会绑定到函数调用的this&lt;/li&gt;
  &lt;li&gt;如果函数没有返回，自动返回这个新对象&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;new是最后一种可以影响函数调用时this绑定行为的方法，我们称之为new绑定&lt;/p&gt;

&lt;h3 id=&quot;优先级&quot;&gt;优先级&lt;/h3&gt;

&lt;p&gt;现在我们已经了解了函数调用中this绑定的四条规则，你需要做的就是找到函数的调用位置并判断应当应用哪条规则。如果某个调用位置可以应用多条，我们按照优先级应用这四条规则。&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;函数是否在new中调用(new绑定)？如果是的话this绑定的是新创建的对象。&lt;/li&gt;
  &lt;li&gt;函数是否通过call、apply(显式绑定)或者硬绑定调用？如果是的话，this绑定的是指定的对象。&lt;/li&gt;
  &lt;li&gt;函数是否在某个上下文对象中调用(隐式绑定)？如果是的话，this绑定的是那个上下文对象。&lt;/li&gt;
  &lt;li&gt;如果都不是的话，使用默认绑定。如果在严格模式下，就绑定到undefined，否则绑定到全局对象。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;结束&quot;&gt;结束&lt;/h2&gt;
&lt;p&gt;一般情况下通过以上四种规则就可以理解大部分的this的使用情况。当然除了这些一般的情况下也有一些例外，比如ES6的箭头函数中的this会继承外层函数调用的this绑定。碰到这些例外情况就具体情况具体分析了。&lt;/p&gt;

</description>
        <pubDate>Sat, 10 Jun 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/%E5%89%8D%E7%AB%AF/2017/06/10/know_everything_about_this.html</link>
        <guid isPermaLink="true">http://localhost:4000/%E5%89%8D%E7%AB%AF/2017/06/10/know_everything_about_this.html</guid>
        
        <category>this</category>
        
        <category>js</category>
        
        
        <category>前端</category>
        
      </item>
    
  </channel>
</rss>
